<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dç²’å­äº¤äº’ç³»ç»Ÿ - ARæ¨¡å¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }

        #video {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 320px;
            height: 180px;
            object-fit: cover;
            z-index: 10;
            transform: scaleX(-1);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        #video:hover {
            opacity: 1;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        #status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(15px);
            padding: 14px 28px;
            border-radius: 30px;
            font-size: 15px;
            z-index: 100;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            font-weight: 500;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ade80;
            margin-right: 10px;
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.6);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.6;
                transform: scale(1.1);
            }
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 24px;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        .upload-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 20px;
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            z-index: 100;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .upload-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            color: #fff;
        }
    </style>
</head>

<body>
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">æ­£åœ¨å¯åŠ¨ARæ¨¡å¼...</div>
    </div>
    <input type="file" id="img-upload" multiple accept="image/*" style="display: none;"
        onchange="handleImageUpload(this)">
    <button class="upload-btn" onclick="document.getElementById('img-upload').click()">
        <span>ğŸ“‚</span> æ¢ç…§ç‰‡
    </button>

    <video id="video" autoplay playsinline muted></video>
    <div id="canvas-container"></div>



    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>

    <script>
        const CONFIG = {
            particleCount: 15000,
            baseScale: 1.0,
            transitionSpeed: 0.15,
            rotationSpeed: 0.002,
            romanticColor: new THREE.Color('#ff1493'),
            normalColor: new THREE.Color('#667eea'),
            treeGreenColor: new THREE.Color('#10b981'),
            treeGoldColor: new THREE.Color('#fbbf24'),
            treeRedColor: new THREE.Color('#ef4444'),
            treeSilverColor: new THREE.Color('#e5e7eb'),
            treeBrownColor: new THREE.Color('#92400e'),
            coinGoldColor: new THREE.Color('#ffd700')
        };

        function createTextParticles(text, count) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 600;
            const height = 300;
            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            ctx.font = 'bold 120px "Microsoft YaHei", "Heiti SC", sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const validPixels = [];

            for (let y = 0; y < height; y += 3) {
                for (let x = 0; x < width; x += 3) {
                    const i = (y * width + x) * 4;
                    if (data[i] > 50) {
                        validPixels.push({
                            x: (x - width / 2) / 80,
                            y: -(y - height / 2) / 80
                        });
                    }
                }
            }

            const positions = [];
            for (let i = 0; i < count; i++) {
                if (validPixels.length > 0) {
                    const pixel = validPixels[Math.floor(Math.random() * validPixels.length)];
                    positions.push(
                        pixel.x + (Math.random() - 0.5) * 0.05,
                        pixel.y + (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.2
                    );
                } else {
                    const theta = Math.random() * Math.PI * 2;
                    const r = 2 * Math.random();
                    positions.push(r * Math.cos(theta), r * Math.sin(theta), (Math.random() - 0.5) * 0.5);
                }
            }
            return new Float32Array(positions);
        }

        const Models = {
            idle: (count) => {
                const positions = [];
                for (let i = 0; i < count; i++) {
                    positions.push(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 12,
                        (Math.random() - 0.5) * 10
                    );
                }
                return new Float32Array(positions);
            },
            heart: (count) => {
                const positions = [];
                for (let i = 0; i < count; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.pow(Math.random(), 0.5);
                    const depth = (Math.random() - 0.5);
                    const heartX = 16 * Math.pow(Math.sin(t), 3);
                    const heartY = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    const scale = 0.08;
                    const thicknessScale = 0.8;
                    positions.push(
                        heartX * r * scale,
                        heartY * r * scale,
                        depth * thicknessScale * (1 - r * 0.3)
                    );
                }
                return new Float32Array(positions);
            },
            tree: (count) => {
                const positions = [];
                const trunkCount = Math.floor(count * 0.04);
                for (let i = 0; i < trunkCount; i++) {
                    const h = Math.random() * 0.3;
                    const angle = Math.random() * Math.PI * 2;
                    const r = 0.12 + Math.random() * 0.08;
                    positions.push(r * Math.cos(angle), h - 2.0, r * Math.sin(angle));
                }
                const mainTreeCount = Math.floor(count * 0.53); // å¢åŠ ä¸»æ ‘å¹²æ¯”ä¾‹ï¼Œå‡å°‘æ ‘é¡¶çš„æ‹¥æŒ¤æ„Ÿ
                for (let i = 0; i < mainTreeCount; i++) {
                    const h = Math.random();
                    const layer = Math.floor(h * 7);
                    const layerH = layer / 7;
                    const layerOffset = (h - layerH) * 7;
                    const angle = h * Math.PI * 18 + Math.random() * Math.PI / 4;
                    const baseR = (1 - layerH) * 2.3;
                    const waveR = Math.sin(layerOffset * Math.PI) * 0.35;
                    const r = (baseR + waveR) * (0.85 + Math.random() * 0.3);
                    const radialPos = Math.pow(Math.random(), 0.6);
                    positions.push(
                        r * radialPos * Math.cos(angle) * 0.6,
                        h * 4.2 - 1.7,
                        r * radialPos * Math.sin(angle) * 0.6
                    );
                }
                const ornamentCount = Math.floor(count * 0.12);
                const ornamentClusters = 25;
                for (let i = 0; i < ornamentCount; i++) {
                    const clusterIdx = Math.floor(Math.random() * ornamentClusters);
                    const clusterH = 0.15 + (clusterIdx / ornamentClusters) * 0.7;
                    const clusterAngle = (clusterIdx * 2.4) % (Math.PI * 2);
                    const clusterR = (1 - clusterH) * 2.0;
                    const cx = clusterR * Math.cos(clusterAngle) * 0.6;
                    const cy = clusterH * 4.2 - 1.7;
                    const cz = clusterR * Math.sin(clusterAngle) * 0.6;
                    const clusterSize = 0.12;
                    positions.push(
                        cx + (Math.random() - 0.5) * clusterSize,
                        cy + (Math.random() - 0.5) * clusterSize,
                        cz + (Math.random() - 0.5) * clusterSize
                    );
                }
                const lightCount = Math.floor(count * 0.08);
                for (let i = 0; i < lightCount; i++) {
                    const h = 0.1 + Math.random() * 0.85;
                    const angle = Math.random() * Math.PI * 2;
                    const r = (1 - h) * 2.3 * 1.08;
                    positions.push(r * Math.cos(angle) * 0.6, h * 4.2 - 1.7, r * Math.sin(angle) * 0.6);
                }
                const coinCount = Math.floor(count * 0.20);
                for (let i = 0; i < coinCount; i++) {
                    const spiralLayer = Math.floor(Math.random() * 3);
                    const spiralRadius = 2.8 + spiralLayer * 0.8;
                    const spiralH = Math.random();
                    const spiralAngle = Math.random() * Math.PI * 2;
                    const coinX = spiralRadius * Math.cos(spiralAngle) * 0.7;
                    const coinY = spiralH * 5.5 - 2.5;
                    const coinZ = spiralRadius * Math.sin(spiralAngle) * 0.7;
                    positions.push(
                        coinX + (Math.random() - 0.5) * 0.3,
                        coinY,
                        coinZ + (Math.random() - 0.5) * 0.3
                    );
                }
                const tipCount = count - trunkCount - mainTreeCount - ornamentCount - lightCount - coinCount;
                for (let i = 0; i < tipCount; i++) {
                    const h = Math.random();
                    // é£æ ¼ç»Ÿä¸€ï¼šä¸å†æ˜¯å®Œç¾çš„åœ†é”¥ï¼Œè€Œæ˜¯å¸¦æœ‰èºæ—‹å’ŒéšæœºæŠ–åŠ¨çš„è‡ªç„¶æ ‘å°–
                    // æ¨¡ä»¿æ ‘èº«çš„ç”Ÿé•¿é€»è¾‘ï¼Œèºæ—‹ä¸Šå‡
                    const y = 2.4 + h * 0.6; // å»¶ä¼¸åˆ° 3.0

                    // åŠå¾„è¡°å‡ï¼Œå‡å°åŠå¾„è®©å…¶æ›´æ¸…çˆ½ï¼Œä¸é‚£ä¹ˆ"æ»¡"
                    const baseR = (1 - h) * 0.22;
                    const r = baseR * (0.8 + Math.random() * 0.4); // éšæœºæŠ–åŠ¨

                    const angle = h * Math.PI * 10 + Math.random() * Math.PI * 2;

                    positions.push(
                        r * Math.cos(angle),
                        y,
                        r * Math.sin(angle)
                    );
                }
                return new Float32Array(positions);
            },
            gesture3: (count) => createTextParticles("å¤§å¤´èœèœ", count),
            gesture2: (count) => createTextParticles("æˆ‘", count),
            gesture1: (count) => createTextParticles("æ°¸è¿œçˆ±ä½ ", count)
        };

        let scene, camera, renderer, particles;
        let cursorMesh;
        let currentModel = 'idle';
        let targetPositions, currentPositions;
        let currentScale = CONFIG.baseScale;
        let isRomanticMode = false;
        let time = 0;

        let isDualHandMode = false;
        let galleryScroll = 0; // ç”»å»Šæ»šåŠ¨åç§»é‡
        let lastSelectedIdx = -1; // ç”¨äºè®°å½•å³æ‰‹æ¡æ‹³é”å®šçš„é€‰ä¸­é¡¹
        let handPosition = { x: 0, y: 0, z: 0 };
        let cursorTarget = { x: 0, y: 0 }; // æ–°å¢ï¼šä¸“é—¨ç”¨äºå…‰æ ‡å’Œäº¤äº’çš„ç›®æ ‡ä½ç½®
        let handVelocity = { x: 0, y: 0 };
        let prevHandPosition = { x: 0, y: 0 };

        let handDepth = 1.0;
        let targetDepth = 1.0;

        // é—®é¢˜3è§£å†³ï¼šæ‰‹åŠ¿ç¨³å®šæ€§æ£€æµ‹
        let gestureStableCounter = 0;
        let lastDetectedGesture = 'idle';
        const GESTURE_STABLE_THRESHOLD = 8;

        let particleColors;

        let imageUrls = [
            'https://picsum.photos/id/237/200/300',
            'https://picsum.photos/id/10/200/300',
            'https://picsum.photos/id/1015/200/300',
            'https://picsum.photos/id/1016/200/300',
            'https://picsum.photos/id/1020/200/300',
            'https://picsum.photos/id/1025/200/300'
        ];

        let floatingImages = [];
        let imageGroup;

        function createFloatingImages() {
            imageGroup = new THREE.Group();
            scene.add(imageGroup);

            const loader = new THREE.TextureLoader();

            imageUrls.forEach((url, i) => {
                const texture = loader.load(url);
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.9
                });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(0.4, 0.6, 1);
                sprite.userData = {
                    id: i,
                    angleOffset: (i / imageUrls.length) * Math.PI * 2,
                    isSelected: false,
                    isZoomed: false,
                    targetScale: 0.4,
                    zoomEffect: 0 // Store random effect type
                };
                imageGroup.add(sprite);
                floatingImages.push(sprite);
            });

            // Default select middle
            galleryScroll = Math.floor(imageUrls.length / 2);
        }

        function handleImageUpload(input) {
            if (input.files && input.files.length > 0) {
                // æ¸…ç†æ—§èµ„æº
                imageUrls.forEach(url => {
                    if (url.startsWith('blob:')) URL.revokeObjectURL(url);
                });

                // ç”Ÿæˆæ–°é“¾æ¥
                imageUrls = Array.from(input.files).map(file => URL.createObjectURL(file));

                // é‡å»ºåœºæ™¯
                if (imageGroup) {
                    scene.remove(imageGroup);
                    floatingImages = [];
                }
                createFloatingImages();

                // æç¤º
                updateStatus(`ğŸ–¼ï¸ å·²åŠ è½½ ${input.files.length} å¼ æ–°ç…§ç‰‡`, true);
                setTimeout(() => updateStatus('ğŸ¥ ARæ¨¡å¼å°±ç»ª', true), 2000);
            }
        }

        // ä¼˜åŒ–ï¼šç…§ç‰‡å…‰æ™•å’Œä¸æ»‘å‡ºåœº
        // ä¼˜åŒ–ï¼šç…§ç‰‡å…‰æ™•å’Œä¸æ»‘å‡ºåœº
        function updateFloatingImages() {
            if (!imageGroup) return;
            const t = time * 0.5;

            // å¦‚æœæ²¡æœ‰åŒæ‰‹æ¨¡å¼ï¼ˆæ‰‹ç¦»å¼€ï¼‰ï¼Œé‡ç½®ä¸€äº›çŠ¶æ€ä»¥é˜²æ®‹ç•™å·¨å¤§å›¾ç‰‡
            // æˆ–è€…æˆ‘ä»¬å¯ä»¥ä¿æŒ"æœ€åä¸€æ¬¡æŸ¥çœ‹"çš„çŠ¶æ€ï¼Ÿ
            // ç”¨æˆ·åé¦ˆï¼šå±å¹•ä¸­æ²¡æœ‰æ‰‹æ—¶ï¼Œå›¾ç‰‡å˜å¾—å·¨å¤§ã€‚è¿™å¯èƒ½æ˜¯å› ä¸º isDualHandMode å˜ä¸º falseï¼Œ
            // å¯¼è‡´ä»£ç èµ°åˆ°äº† else åˆ†æ”¯ï¼Œè€Œ sprite.userData.isZoomed/isSelected è¿˜æ˜¯ trueã€‚
            // ä¹‹å‰çš„ else åˆ†æ”¯å¯¹ isSelected å¤„ç†æ˜¯ targetScale = 2.5 (å·¨å¤§)ã€‚

            // ä¿®å¤ï¼šå¦‚æœæ²¡æœ‰æ‰‹æ£€æµ‹åˆ° (æˆ–è€…å•æ‰‹)ï¼Œå¼ºåˆ¶å–æ¶ˆåŒæ‰‹çš„ Zoom çŠ¶æ€ï¼Œé¿å…æ„å¤–å¤§å›¾
            // é™¤éæˆ‘ä»¬æƒ³è®¾è®¡æˆ"æ”¾æ‰‹åä¿æŒå±•ç¤º"ã€‚ä½†ç”¨æˆ·è¯´çš„æ˜¯"å˜å¾—å·¨å¤§"ï¼Œè¯´æ˜æ˜¯ä¸é¢„æœŸçš„ã€‚
            if (!isDualHandMode) {
                // ç¨å¾®æ¸…ç†ä¸€ä¸‹ Zoom çŠ¶æ€ï¼Œé¿å…åˆ‡å›å•æ‰‹/æ— æ‰‹æ—¶çªç„¶å˜å¤§
                // ä¸è¿‡æˆ‘ä»¬è¿˜æ˜¯è¦æ”¯æŒå•æ‰‹æ¨¡å¼ï¼Ÿç”¨æˆ·ä¹‹å‰è¯´è¿‡å»é™¤å•æ‰‹é€‰å–ã€‚
                // æ‰€ä»¥å¦‚æœæ²¡æœ‰åŒæ‰‹ï¼Œåº”è¯¥å°±åªæ˜¯å±•ç¤ºæ ‘ï¼Œä¸åº”è¯¥æœ‰é€‰ä¸­çš„å¤§å›¾ã€‚
            }

            floatingImages.forEach((sprite, i) => {
                let targetPos = new THREE.Vector3();
                let targetScale = 0.0;
                let targetOpacity = 0.0;

                if (isDualHandMode) {
                    // Check if any focus mode is active
                    let hasZoomed = floatingImages.some(img => img.userData.isZoomed);

                    // --- æ— å°½ç”»å»Šé€»è¾‘ (Infinite Gallery) ---
                    const total = floatingImages.length;
                    let relIdx = i - galleryScroll;
                    relIdx = relIdx - total * Math.round(relIdx / total);

                    const angleSpacing = 0.25;
                    const radius = 3.5;
                    const theta = relIdx * angleSpacing;

                    // åŸºç¡€ä½ç½®ï¼šåœ†å¼§æ’åˆ—
                    const baseX = radius * Math.sin(theta);
                    const baseZ = 2.0 - radius * (1 - Math.cos(theta));

                    targetPos.set(baseX, 0, baseZ);
                    targetScale = 0.3;

                    // Reset color
                    sprite.material.color.setHex(0xffffff);
                    targetOpacity = 0.6; // Base opacity

                    if (sprite.userData.isZoomed) {
                        // ã€Hero Modeã€‘
                        targetPos.set(0, 0.5, 2.5);
                        targetScale = 0.8;
                        targetOpacity = 1.0;

                        const rotX = Math.sin(time * 0.5) * 0.05 + Math.cos(time * 0.3) * 0.02;
                        const rotY = Math.cos(time * 0.4) * 0.05 + Math.sin(time * 0.2) * 0.02;

                        sprite.lookAt(camera.position);
                        sprite.rotateX(rotX);
                        sprite.rotateY(rotY);

                    } else if (hasZoomed) {
                        // èƒŒæ™¯æ¨¡å¼
                        targetScale = 0.2;
                        targetOpacity = 0.05;
                        targetPos.z -= 1.0;
                        sprite.lookAt(camera.position);

                    } else if (sprite.userData.isSelected) {
                        // ã€Hover Modeã€‘
                        targetPos.z += 0.8;
                        targetPos.y = 0.5;
                        targetScale = 0.45;
                        targetOpacity = 1.0;

                        sprite.lookAt(camera.position);
                        targetScale += Math.sin(time * 4) * 0.01;

                    } else {
                        // æ™®é€šæ¨¡å¼
                        const dist = Math.abs(relIdx);
                        targetOpacity = Math.max(0.0, 0.6 - dist * 0.15);
                        sprite.lookAt(camera.position);
                        targetPos.z -= dist * 0.2;
                    }

                } else {
                    // --- å•æ‰‹ / æ— æ‰‹æ¨¡å¼ ---
                    if (currentModel === 'tree') {
                        // æŒ‚åœ¨æ ‘ä¸Šçš„ä½ç½®
                        const count = floatingImages.length;
                        const p = i / count;
                        const y = 2.0 - p * 3.5;
                        const r = 0.3 + p * 1.3;
                        const spirals = 3;
                        const angle = sprite.userData.angleOffset + p * Math.PI * 2 * spirals + t * 0.2;

                        targetPos.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                        targetScale = 0.12;

                        sprite.material.color.setHex(0xffffff);
                        targetOpacity = 0.9;

                    } else if (currentModel === 'idle' && handDepth > 1.0) {
                        // æ»¡å¤©æ˜Ÿä¸‹çš„æµªæ¼«å›å¿†
                        const angle = sprite.userData.angleOffset + t * 0.15;
                        const r = 2.5;
                        const yOffset = Math.sin(angle * 1.5 + t * 0.4) * 0.8;

                        targetPos.set(
                            Math.cos(angle) * r,
                            yOffset,
                            Math.sin(angle) * r * 0.5
                        );

                        sprite.lookAt(camera.position);

                        // ä¸¥æ ¼çš„ä¸€ä¸ªä¸€ä¸ªå‡ºç°é€»è¾‘
                        // é—´éš”æ›´å¤§ï¼Œæ·¡å…¥æ›´å¿«
                        const startDepth = 1.1;
                        const revealSpacing = 0.15; // æ¯å¼ å›¾é—´éš”çš„æ·±åº¦
                        const fadeDuration = 0.05; // æ¯å¼ å›¾æ·¡å…¥éœ€è¦çš„æ·±åº¦è·¨åº¦ (å°äºé—´éš”ï¼Œä¿è¯æ— é‡å )

                        const myStart = startDepth + i * revealSpacing;

                        let alpha = (handDepth - myStart) / fadeDuration;
                        alpha = Math.max(0.0, Math.min(1.0, alpha));

                        targetOpacity = 0.95 * alpha;
                        targetScale = 0.2 + 0.3 * alpha;

                        sprite.material.color.setHex(0xffffff);

                        // ç¬ç§»é€»è¾‘
                        if (sprite.scale.x < 0.1 || alpha < 0.01) {
                            sprite.position.copy(targetPos);
                        }

                    } else {
                        // éšè—æ¨¡å¼ - åŸåœ°é€æ¸æ¶ˆå¤±ï¼Œä¸é£èµ°
                        targetPos.copy(sprite.position);
                        targetScale = 0.0;
                        targetOpacity = 0.0;
                    }
                }

                // Physics Update
                sprite.position.lerp(targetPos, 0.08);

                // Scale Update
                const currentS = sprite.scale.x;
                const newS = currentS + (targetScale - currentS) * 0.1;
                sprite.scale.set(newS, newS * 1.5, 1);

                // Opacity Update (Smooth Fade)
                // è§£å†³æ·¡å¦‚æ·¡å‡ºå¤ªå¿«çš„é—®é¢˜ï¼Œç”¨è¾ƒå°çš„ç³»æ•° 0.05
                sprite.material.opacity += (targetOpacity - sprite.material.opacity) * 0.05;
            });
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = null;

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3.5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createParticleSystem();
            createFloatingImages();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            // åˆ›å»ºå…‰æ ‡ - é—®é¢˜2è§£å†³ï¼šå»é™¤å±å¹•ä¸­é—´çš„åœ†åœˆ
            // const cursorGeometry = new THREE.RingGeometry(0.08, 0.1, 32);
            // const cursorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
            // cursorMesh = new THREE.Mesh(cursorGeometry, cursorMaterial);
            // scene.add(cursorMesh);

            window.addEventListener('resize', onWindowResize);
        }

        // ç”Ÿæˆç²’å­çº¹ç†å›¾é›†
        function createTextureAtlas() {
            const canvas = document.createElement('canvas');
            const size = 1024; // 256px per cell * 4
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);

            const cellSize = 256;
            const icons = [
                'âšª', // 0: Default
                'ğŸ', // 1: Gift
                'ğŸ§¦', // 2: Sock
                'ğŸ””', // 3: Bell
                'ğŸ‘”', // 4: Tie
                'ğŸ”º', // 5: Triangle
                'ğŸ„', // 6: Tree
                'ğŸ…', // 7: Santa
                'ğŸª™', // 8: Coin
                'â­', // 9: Star (Custom Draw)
                'â„ï¸', // 10: Snowflake
                'â¤ï¸', // 11: Heart
                'â›„', // 12: Snowman
                'âœ¨', // 13: Sparkles
                'ğŸ”´', // 14: Sphere
                'ğŸŸ©'  // 15: Cube
            ];

            ctx.font = '180px apple color emoji, segoe ui emoji, notocolor emoji';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < 16; i++) {
                const x = (i % 4) * cellSize;
                const y = Math.floor(i / 4) * cellSize;
                const cx = x + cellSize / 2;
                const cy = y + cellSize / 2;

                // Draw icon
                if (i === 0) {
                    // Draw a nice gradient circle for default
                    const grad = ctx.createRadialGradient(cx, cy, 10, cx, cy, 110);
                    grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                    grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 110, 0, Math.PI * 2);
                    ctx.fill();
                } else if (i === 9) {
                    // é—®é¢˜1è§£å†³ï¼šæ‰‹ç»˜äº”è§’æ˜Ÿ
                    // ç”¨æˆ·åé¦ˆï¼šè¦æ ‡å‡†çš„äº”è§’æ˜Ÿï¼Œä¸è¦å¤ªèƒ–åƒäº”è¾¹å½¢
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.beginPath();
                    const outerRadius = 110;
                    const innerRadius = 45;  // è°ƒå›æ ‡å‡†æ¯”ä¾‹ (approx 0.4 of outer)ï¼Œå˜å°–

                    // æ—‹è½¬ä¿®æ­£ï¼Œè®©ä¸€ä¸ªè§’å‚ç›´å‘ä¸Š
                    ctx.rotate(-Math.PI / 2); // -90åº¦ï¼Œè§’æœä¸Š

                    for (let n = 0; n < 5; n++) {
                        const angleOuter = (n * Math.PI * 2) / 5;
                        const angleInner = ((n + 0.5) * Math.PI * 2) / 5;

                        // Outer Point
                        if (n === 0) ctx.moveTo(Math.cos(angleOuter) * outerRadius, Math.sin(angleOuter) * outerRadius);
                        else ctx.lineTo(Math.cos(angleOuter) * outerRadius, Math.sin(angleOuter) * outerRadius);

                        // Inner Point
                        ctx.lineTo(Math.cos(angleInner) * innerRadius, Math.sin(angleInner) * innerRadius);
                    }
                    ctx.closePath();

                    // æŸ”å’Œçš„æš–è‰²æ¸å˜
                    const starGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 100);
                    starGrad.addColorStop(0, '#fffbe6'); // ä¸­å¿ƒç”šè‡³æœ‰ç‚¹ç™½
                    starGrad.addColorStop(0.4, '#ffd700'); // é‡‘è‰²
                    starGrad.addColorStop(1, '#ff8c00');   // è¾¹ç¼˜æ©™è‰²

                    ctx.fillStyle = starGrad;

                    // åœ†è§’è¿æ¥ï¼Œä¿æŒä¸€ç‚¹ç‚¹åœ†æ¶¦æ„Ÿï¼Œä½†ä¸è‡³äºå˜æˆçƒ
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.lineWidth = 8; // çº¿æ¡å‡ç»†ä¸€ç‚¹ï¼Œé¿å…è®©è§’æ˜¾å¾—å¤ªé’
                    ctx.strokeStyle = '#ffd700';
                    ctx.stroke();
                    ctx.fill();

                    ctx.restore();
                } else {
                    const icon = icons[i] || 'â“';
                    ctx.fillText(icon, cx, cy + 10);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.flipY = false;
            return texture;
        }

        // é¡¶ç‚¹ç€è‰²å™¨
        const vertexShader = `
            attribute float size;
            attribute vec3 customColor;
            attribute float shapeIndex;
            varying vec3 vColor;
            varying float vShapeIndex;
            varying vec3 vPosition;
            varying float vAlpha;
            uniform float uTime;
            uniform float uScale;
            uniform float uHandDepth;

            void main() {
                vColor = customColor;
                vShapeIndex = shapeIndex;
                vPosition = position;
                
                // ä¸æ»‘çš„å‘¼å¸æ•ˆæœ
                float pulse = 1.0 + 0.1 * sin(uTime * 2.0 + position.x * 2.0);
                
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                // å¤§å°éšæ·±åº¦å’Œå‘¼å¸å˜åŒ–
                float depthScale = smoothstep(5.0, 1.0, -mvPosition.z); // è¿‘å¤§è¿œå°ä¼˜åŒ–
                gl_PointSize = size * uScale * uHandDepth * pulse * (400.0 / -mvPosition.z);
                
                // è¾¹ç¼˜æ¸éš
                vAlpha = min(1.0, 1.5 - length(position.xy) / 8.0);
            }
        `;

        // ç‰‡å…ƒç€è‰²å™¨ - æ”¯æŒå›¾é›†å’Œåå…‰
        const fragmentShader = `
            uniform sampler2D uTexture;
            uniform float uTime;
            varying vec3 vColor;
            varying float vShapeIndex;
            varying float vAlpha;

            void main() {
                float index = floor(vShapeIndex + 0.5);
                vec2 uv = gl_PointCoord;
                
                // æ˜Ÿæ˜Ÿ(Index 9)è‡ªè½¬é€»è¾‘ï¼šä¸åœ£è¯æ ‘åæ–¹å‘æ—‹è½¬
                // åœ£è¯æ ‘æ˜¯ç»•Yè½´è½¬ï¼Œæ˜Ÿæ˜Ÿä½œä¸º2Dè´´å›¾ï¼Œæˆ‘ä»¬è®©å®ƒè¿›è¡Œ2Dè‡ªè½¬æ¥å®ç°è§†è§‰ä¸Šçš„æ—‹è½¬æ„Ÿ
                if (abs(index - 9.0) < 0.1) {
                     vec2 center = vec2(0.5);
                     // æ ‘æ˜¯é¡ºæ—¶é’ˆ(æ­£å‘angle)ï¼Œæ˜Ÿæ˜Ÿå°±é€†æ—¶é’ˆ(è´Ÿå‘angle)
                     // è°ƒæ•´é€Ÿåº¦è®©å®ƒçœ‹èµ·æ¥ä¼˜é›…
                     float angle = uTime * 1.0; 
                     float s = sin(angle);
                     float c = cos(angle);
                     vec2 centered = uv - center;
                     // æ—‹è½¬çŸ©é˜µ
                     uv = vec2(
                         centered.x * c - centered.y * s,
                         centered.x * s + centered.y * c
                     ) + center;
                     
                     // æ—‹è½¬åå¦‚æœè¶…å‡º[0,1]èŒƒå›´åˆ™ä¸¢å¼ƒï¼Œé˜²æ­¢æ˜¾ç¤ºå‡ºé‚»è¿‘çš„å›¾æ ‡
                     if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) discard;
                }

                // è®¡ç®—å½“å‰ç²’å­åœ¨å›¾é›†ä¸­çš„UV
                float col = mod(index, 4.0);
                float row = 3.0 - floor(index / 4.0); // flipY handled in JS, but grid is top-down usually
                
                // æ˜ å°„åˆ°å›¾é›†åæ ‡
                vec2 finalUV = uv;
                finalUV.x = (finalUV.x + col) / 4.0;
                finalUV.y = (finalUV.y + row) / 4.0;

                vec4 texColor = texture2D(uTexture, finalUV);
                
                if (texColor.a < 0.1) discard;

                // åå…‰æ•ˆæœ (Sheen)
                float sheen = 0.0;
                if (index > 0.5) { // å¯¹Emojiæ·»åŠ æµå…‰
                     // æ˜Ÿæ˜Ÿçš„æµå…‰ä¹Ÿè·Ÿéšæ—‹è½¬ç¨å¾®å˜åŠ¨ä¸€ä¸‹
                     float sheenPos = (uv.x + uv.y) * 3.0 - uTime * 3.0;
                     sheen = max(0.0, sin(sheenPos)) * 0.3;
                }

                // æ˜Ÿæ˜Ÿ(index 9)å‘å…‰ç‰¹æ•ˆ
                vec3 finalColor = vColor + sheen;
                float alpha = texColor.a * vAlpha * 0.95;

                if (abs(index - 9.0) < 0.1) {
                    // æ˜Ÿæ˜Ÿå‘å…‰å¢å¼º
                    float glow = 0.5 + 0.5 * sin(uTime * 3.0); // å¼ºçƒˆçš„å‘¼å¸å…‰
                    finalColor += vec3(0.5, 0.4, 0.1) * glow; // é‡‘è‰²å…‰æ™•å åŠ 
                    
                    // æ ¸å¿ƒæ›´äº®
                    finalColor *= 1.5;
                }

                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            targetPositions = Models[currentModel](CONFIG.particleCount);
            currentPositions = new Float32Array(targetPositions); // Start positions

            // åˆå§‹åŒ– buffer
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(CONFIG.particleCount * 3), 3));
            geometry.getAttribute('position').set(currentPositions); // Set initial

            particleColors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            const shapeIndices = new Float32Array(CONFIG.particleCount);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                particleColors[i * 3] = CONFIG.normalColor.r;
                particleColors[i * 3 + 1] = CONFIG.normalColor.g;
                particleColors[i * 3 + 2] = CONFIG.normalColor.b;
                sizes[i] = 0.05 + Math.random() * 0.05; // åŸºç¡€å¤§å°

                // éšæœºåˆ†é…å½¢çŠ¶ï¼Œåœ†å½¢(0)æ¦‚ç‡æœ€é«˜
                const r = Math.random();
                if (r < 0.6) shapeIndices[i] = 0; // åœ†å½¢
                else if (r < 0.65) shapeIndices[i] = 1; // ç¤¼ç‰©
                else if (r < 0.68) shapeIndices[i] = 2; // è¢œå­
                else if (r < 0.71) shapeIndices[i] = 3; // é“ƒé“›
                else if (r < 0.74) shapeIndices[i] = 4; // é¢†å¸¦
                else if (r < 0.77) shapeIndices[i] = 5; // ä¸‰è§’å½¢
                else if (r < 0.80) shapeIndices[i] = 7; // åœ£è¯è€äºº
                else if (r < 0.83) shapeIndices[i] = 8; // é‡‘å¸
                else if (r < 0.86) shapeIndices[i] = 10; // é›ªèŠ±
                else if (r < 0.89) shapeIndices[i] = 12; // é›ªäºº
                else if (r < 0.92) shapeIndices[i] = 13; // é—ªå…‰
                else shapeIndices[i] = 9; // æ˜Ÿæ˜Ÿ
            }

            // å¼ºåˆ¶è®¾ç½®æ ‘é¡¶æ˜Ÿæ˜Ÿ (å¦‚æœéœ€è¦ç‰¹å®šID)
            // è¿™é‡Œæˆ‘ä»¬å°†åœ¨ update ä¸­åŠ¨æ€è°ƒæ•´æ ‘é¡¶ç²’å­çš„å½¢çŠ¶ï¼Œä½†å…ˆé¢„è®¾ä¸€ä¸ªåˆå§‹å€¼
            // å°†æœ€åä¸€ä¸ªç²’å­ä½œä¸ºæ˜Ÿæ˜Ÿ

            geometry.setAttribute('customColor', new THREE.BufferAttribute(particleColors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('shapeIndex', new THREE.BufferAttribute(shapeIndices, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uScale: { value: 1.0 },
                    uHandDepth: { value: 1.0 },
                    uTexture: { value: createTextureAtlas() }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                // è§£å†³æ˜Ÿæ˜Ÿå¯èƒ½è¢«æˆªæ–­çš„é—®é¢˜ï¼Œå°è¯•ç¦ç”¨å‰”é™¤æˆ–è€…ä¸å®Œå…¨ä¾èµ– FrustumCulling (å°½ç®¡ Points é»˜è®¤å°±æœ‰)
            });

            particles = new THREE.Points(geometry, material);
            // è°ƒæ•´ç›¸æœºä½ç½®æˆ–è€…æ¨¡å‹æ•´ä½“ä½ç½®ï¼Œç¡®ä¿æ˜Ÿæ˜Ÿå¯è§
            // æˆ–è€…åœ¨æ¨¡å‹ç”Ÿæˆæ—¶è°ƒæ•´é«˜åº¦ã€‚è¿™é‡Œæˆ‘ä»¬å¾®è°ƒä¸€ä¸‹ç›¸æœº
            camera.position.y = 0.5; // ç¨å¾®æŠ¬é«˜ç›¸æœº

            scene.add(particles);

            // ç¡®ä¿æ–‡å­—ç²’å­æ¨¡å¼åˆå§‹ä½ç½®æ­£ç¡®
            // ... (positions are already in targetPositions)
        }

        function updateParticlePositions() {
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.customColor.array; // Shader uses customColor
            const shapes = particles.geometry.attributes.shapeIndex.array;
            const sizes = particles.geometry.attributes.size.array;

            const isTextMode = (currentModel === 'gesture1' || currentModel === 'gesture2' || currentModel === 'gesture3');

            // ä¸æ»‘æ’å€¼å› å­
            const lerpFactor = 0.08;

            for (let i = 0; i < positions.length; i += 3) {
                let targetX = targetPositions[i] * currentScale;
                let targetY = targetPositions[i + 1] * currentScale;
                let targetZ = targetPositions[i + 2] * currentScale;



                positions[i] += (targetX - positions[i]) * lerpFactor;
                positions[i + 1] += (targetY - positions[i + 1]) * lerpFactor;
                positions[i + 2] += (targetZ - positions[i + 2]) * lerpFactor;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.shapeIndex.needsUpdate = true;
            particles.geometry.attributes.size.needsUpdate = true;

            // Update Uniforms
            particles.material.uniforms.uTime.value = time;
            particles.material.uniforms.uHandDepth.value = handDepth * (isRomanticMode ? 1.1 : 1.0);

            // Color Logic (Optimized)
            if (currentModel === 'tree') {
                const pCount = CONFIG.particleCount;
                // Simple gradient logic based on index for simplicity & performance
                for (let i = 0; i < pCount; i++) {
                    // Removed obsolete star skip

                    let targetColor = CONFIG.treeGreenColor;
                    if (shapes[i] === 1 || shapes[i] === 7) targetColor = CONFIG.treeRedColor; // Gift/Santa
                    else if (shapes[i] === 8 || shapes[i] === 3) targetColor = CONFIG.coinGoldColor; // Coin/Bell
                    else if (shapes[i] === 2) targetColor = CONFIG.treeSilverColor; // Sock

                    if (shapes[i] !== 0 && shapes[i] !== 6) { // Special items should pop
                        // Slight flash
                        targetColor = targetColor.clone().lerp(new THREE.Color(1, 1, 1), 0.2 * Math.sin(time * 5 + i));
                    }

                    // Trunk logic (bottom particles roughly) - simplified for stability
                    if (targetPositions[i * 3 + 1] < -1.5 && Math.abs(targetPositions[i * 3]) < 0.5) {
                        targetColor = CONFIG.treeBrownColor;
                        shapes[i] = 0; // Force trunk to dots
                    }

                    // Tree Tip logic is removed to allow random particles

                    colors[i * 3] += (targetColor.r - colors[i * 3]) * 0.05;
                    colors[i * 3 + 1] += (targetColor.g - colors[i * 3 + 1]) * 0.05;
                    colors[i * 3 + 2] += (targetColor.b - colors[i * 3 + 2]) * 0.05;
                }
            } else {
                let activeColor = CONFIG.normalColor;
                let isChristmasVibe = false;

                if (currentModel === 'heart' || currentModel === 'gesture1') {
                    activeColor = CONFIG.romanticColor;
                } else if (currentModel === 'idle' && handDepth > 1.2) {
                    // æ»¡å¤©æ˜Ÿ(idle)ä¸”æ‰‹æŒé è¿‘(handDepthå¤§) -> åœ£è¯æ°›å›´
                    isChristmasVibe = true;
                }

                for (let i = 0; i < CONFIG.particleCount; i++) {
                    let targetR, targetG, targetB;

                    if (isChristmasVibe) {
                        // åœ£è¯é…è‰²ç­–ç•¥
                        const s = shapes[i];
                        let c;
                        // æ ¹æ®å½¢çŠ¶æˆ–éšæœºåˆ†é…
                        if (s === 1 || s === 7 || s === 11) c = CONFIG.treeRedColor; // Gift, Santa, Heart
                        else if (s === 3 || s === 8 || s === 9) c = CONFIG.coinGoldColor; // Bell, Coin, Star
                        else if (s === 2 || s === 10 || s === 12) c = CONFIG.treeSilverColor; // Sock, Snowflake, Snowman
                        else if (s === 6 || s === 5 || s === 15) c = CONFIG.treeGreenColor; // Tree, Triangle, Cube
                        else {
                            // å¯¹äºæ™®é€šåœ†ç‚¹(0)å’Œå…¶ä»–ï¼Œéšæœºåˆ†é…çº¢ç»¿é‡‘
                            const mod = i % 10;
                            if (mod < 4) c = CONFIG.treeGreenColor;
                            else if (mod < 7) c = CONFIG.treeRedColor;
                            else c = CONFIG.coinGoldColor;
                        }

                        // äº®åº¦å¢å¼º (Overdrive)
                        targetR = c.r * 1.8;
                        targetG = c.g * 1.8;
                        targetB = c.b * 1.8;
                    } else {
                        targetR = activeColor.r;
                        targetG = activeColor.g;
                        targetB = activeColor.b;
                    }

                    colors[i * 3] += (targetR - colors[i * 3]) * 0.1;
                    colors[i * 3 + 1] += (targetG - colors[i * 3 + 1]) * 0.1;
                    colors[i * 3 + 2] += (targetB - colors[i * 3 + 2]) * 0.1;
                }
            }
            particles.geometry.attributes.customColor.needsUpdate = true;
        }

        function changeModel(modelName) {
            if (currentModel !== modelName && Models[modelName]) {
                currentModel = modelName;
                targetPositions = Models[modelName](CONFIG.particleCount);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let hands;

        async function initMediaPipe() {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
            });

            hands.setOptions({
                maxNumHands: 2, // Enable 2 hands
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandsResults);

            const videoElement = document.getElementById('video');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720, facingMode: 'user' }
                });
                videoElement.srcObject = stream;
                await new Promise(resolve => videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    resolve();
                });

                async function sendFrame() {
                    await hands.send({ image: videoElement });
                    requestAnimationFrame(sendFrame);
                }
                sendFrame();
                updateStatus('ğŸ¥ ARæ¨¡å¼å°±ç»ª - è¯·å±•ç¤ºæ‰‹åŠ¿', true);
            } catch (error) {
                console.error('æ‘„åƒå¤´é”™è¯¯:', error);
                updateStatus('æ‘„åƒå¤´è®¿é—®å¤±è´¥', false);
            }
        }

        function onHandsResults(results) {
            // Helper for distance
            const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Identify Hands
                let leftHand = null;
                let rightHand = null;

                // MediaPipe MultiHandedness: label 'Left' means user's left hand usually.
                // However, visual mirroring might affect perception.
                // Let's rely on standard logic: Label 'Left' -> Left Hand, 'Right' -> Right Hand.
                for (let i = 0; i < results.multiHandedness.length; i++) {
                    const label = results.multiHandedness[i].label;
                    const landmarks = results.multiHandLandmarks[i];
                    if (label === 'Right') rightHand = landmarks;
                    if (label === 'Left') leftHand = landmarks;
                }

                // --- Scenario 1: Dual Hand Gallery Mode ---
                // Condition: Both hands detected AND current model is Tree (or we allow switching to it)
                // Actually user said "When hands open, start selection". 
                // Let's be strict: If 2 hands are visible, we enter "Photo Selection Mode" overlay.

                if (leftHand && rightHand) {
                    isDualHandMode = true;
                    // åŒæ‰‹æ¨¡å¼
                    let statusText = "ğŸ‘ åŒæ‰‹æ¨¡å¼ | â†”ï¸ æ§åˆ¶æ‰‹è·ä»¥æ»‘åŠ¨ | âœŠ æ¡æ‹³å±•ç¤º";

                    const lPalm = leftHand[9];
                    const rPalm = rightHand[9];

                    // 1. Left Hand: Speed Control (Based on distance from Right Hand)
                    // Logic: Expand -> Scroll Left / Shrink -> Scroll Right
                    const separation = Math.abs(lPalm.x - rPalm.x);

                    let speed = 0;
                    const minSep = 0.25;
                    const maxSep = 0.55;

                    // Left Hand Fist Detection for Acceleration
                    const lWrist = leftHand[0];
                    const distCheck = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                    const isLExtended = (tipIdx, pipIdx) => distCheck(leftHand[tipIdx], lWrist) > distCheck(leftHand[pipIdx], lWrist) * 1.1;

                    let lFingersOpen = 0;
                    if (isLExtended(8, 6)) lFingersOpen++;
                    if (isLExtended(12, 10)) lFingersOpen++;
                    if (isLExtended(16, 14)) lFingersOpen++;
                    if (isLExtended(20, 18)) lFingersOpen++;

                    // If Left Fist (<=1 finger open), Turbo Boost!
                    const isLeftFist = lFingersOpen <= 1;
                    const speedMultiplier = isLeftFist ? 4.0 : 1.0; // 4å€é€Ÿ

                    if (isLeftFist) statusText = "âš¡ å·¦æ‰‹æ¡æ‹³åŠ é€Ÿä¸­! âš¡";

                    if (separation < minSep) {
                        // Hands close
                        speed = 0.04 * speedMultiplier * ((minSep - separation) / 0.15);
                    } else if (separation > maxSep) {
                        // Hands far
                        speed = -0.04 * speedMultiplier * ((separation - maxSep) / 0.15);
                    }

                    galleryScroll += speed;

                    // Soft Clamp Removed for Infinite Scroll
                    // const maxScroll = floatingImages.length - 1;
                    // if (galleryScroll < -0.5) galleryScroll = -0.5;
                    // if (galleryScroll > maxScroll + 0.5) galleryScroll = maxScroll + 0.5;

                    // 2. Right Hand: Selection & Zoom
                    const rX = -(rPalm.x - 0.5) * 4;
                    // Detect Right Fist
                    const rWrist = rightHand[0];
                    const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                    const isRExtended = (tipIdx, pipIdx) => dist(rightHand[tipIdx], rWrist) > dist(rightHand[pipIdx], rWrist) * 1.1;

                    let rFingersOpen = 0;
                    if (isRExtended(8, 6)) rFingersOpen++;
                    if (isRExtended(12, 10)) rFingersOpen++;
                    if (isRExtended(16, 14)) rFingersOpen++;
                    if (isRExtended(20, 18)) rFingersOpen++;
                    const isRightFist = rFingersOpen <= 1;

                    let selectedIdx = -1;

                    if (isRightFist && lastSelectedIdx !== -1) {
                        selectedIdx = lastSelectedIdx;
                        statusText = "âœ¨ æ­£åœ¨å±•ç¤ºå›¾ç‰‡ âœ¨";
                    } else {
                        // New Selection Logic for Infinite Scroll
                        // Find the image whose "wrapped index" is closest to 0
                        const total = floatingImages.length;
                        selectedIdx = -1;
                        let minDiff = 100;

                        for (let i = 0; i < total; i++) {
                            // Calculate wrapped relative index exactly as in updateFloatingImages
                            let relIdx = i - galleryScroll;
                            relIdx = relIdx - total * Math.round(relIdx / total);

                            // If this image is effectively "in the center" (relIdx close to 0)
                            if (Math.abs(relIdx) < 0.5 && Math.abs(relIdx) < minDiff) {
                                minDiff = Math.abs(relIdx);
                                selectedIdx = i;
                            }
                        }

                        if (selectedIdx !== -1) lastSelectedIdx = selectedIdx;
                        else lastSelectedIdx = -1;
                    }

                    // Apply States
                    floatingImages.forEach((img, i) => {
                        img.userData.isSelected = (i === selectedIdx);
                        img.userData.isZoomed = (i === selectedIdx && isRightFist);
                    });

                    if (currentModel !== 'tree') changeModel('tree');

                    updateStatus(statusText, true);
                    return; // Skip single hand logic
                }

                // Reset Dual Mode states if hands lost
                isDualHandMode = false;
                if (floatingImages) {
                    floatingImages.forEach(img => {
                        img.userData.isSelected = false;
                        img.userData.isZoomed = false;
                    });
                }

                isDualHandMode = false; // Reset if single hand


                // --- Scenario 2: Single Hand Logic (Fallback/Original) ---
                // Use the first detected hand (or whichever is dominant/detected).
                const landmarks = results.multiHandLandmarks[0];

                const palm = landmarks[9];
                const newX = -(palm.x - 0.5) * 4;
                const newY = -(palm.y - 0.5) * 3;

                const thumbTip = landmarks[4];
                const pinkyTip = landmarks[20];
                const handWidth = Math.sqrt(
                    Math.pow(thumbTip.x - pinkyTip.x, 2) +
                    Math.pow(thumbTip.y - pinkyTip.y, 2)
                );

                targetDepth = Math.max(0.5, Math.min(2.0, handWidth * 4));
                handDepth += (targetDepth - handDepth) * 0.1;

                handPosition.y = newY;

                // Keep cursorTarget synced with palm by default
                cursorTarget.x = newX;
                cursorTarget.y = newY;

                const indexTip = landmarks[8];
                const thumbTip4 = landmarks[4];

                // Pinch Center
                const pinchCenterX = (indexTip.x + thumbTip4.x) / 2;
                const pinchCenterY = (indexTip.y + thumbTip4.y) / 2;
                const interactionX = -(pinchCenterX - 0.5) * 4;
                const interactionY = -(pinchCenterY - 0.5) * 3;
                // Update cursor target
                cursorTarget.x = interactionX;
                cursorTarget.y = interactionY;

                // --- Single Hand Image Interaction Removed ---
                // User requested to remove single hand selection.
                // We keep 'interactingImage' variable as null to avoid breaking later checks if any,
                // but effectively disable the logic.

                let interactingImage = null;

                const wrist = landmarks[0];
                const palmScale = dist(landmarks[0], landmarks[9]);

                const isExtended = (tipIdx, pipIdx) => dist(landmarks[tipIdx], wrist) > dist(landmarks[pipIdx], wrist) * 1.05;
                const isThumbExtended = dist(landmarks[4], landmarks[17]) > palmScale * 1.2 && dist(landmarks[4], landmarks[5]) > palmScale * 0.3;

                const isIndexExt = isExtended(8, 6);
                const isMiddleExt = isExtended(12, 10);
                const isRingExt = isExtended(16, 14);
                const isPinkyExt = isExtended(20, 18);

                const extendedCount = [isIndexExt, isMiddleExt, isRingExt, isPinkyExt].filter(Boolean).length;

                const pinchDist = dist(landmarks[4], landmarks[8]);
                const isPinch = pinchDist < palmScale * 0.25;

                const isCurled = (tipIdx, pipIdx) => dist(landmarks[tipIdx], wrist) < dist(landmarks[pipIdx], wrist) * 1.35;

                let detectedGesture = 'idle';
                let statusText = "ğŸ–ï¸ æ•£å¼€";
                let newRomanticMode = isRomanticMode;

                if (isPinch) {
                    if (isMiddleExt && isRingExt && isPinkyExt) {
                        detectedGesture = 'gesture3';
                        newRomanticMode = false;
                        statusText = "ğŸ‘Œ å¤§å¤´èœèœ";
                    } else if (isCurled(12, 10) && isCurled(16, 14) && isCurled(20, 18)) {
                        detectedGesture = 'heart';
                        newRomanticMode = true;
                        statusText = "â¤ï¸ çˆ±å¿ƒ";
                    } else if (!isMiddleExt && !isRingExt && !isPinkyExt) {
                        detectedGesture = 'heart';
                        newRomanticMode = true;
                        statusText = "â¤ï¸ çˆ±å¿ƒ";
                    } else {
                        detectedGesture = lastDetectedGesture;
                        statusText = "è°ƒæ•´ä¸­...";
                    }
                } else {
                    const isOneFinger = isIndexExt && !isMiddleExt && !isRingExt && !isPinkyExt;
                    const isVictory = isIndexExt && isMiddleExt && isCurled(16, 14) && isCurled(20, 18);

                    if (extendedCount === 0 && !isThumbExtended) {
                        detectedGesture = 'tree';
                        newRomanticMode = true;
                        statusText = "âœŠ ğŸ„ğŸ’° åœ£è¯æ ‘";
                    } else if (isOneFinger) {
                        detectedGesture = 'gesture1';
                        newRomanticMode = true;
                        statusText = "â˜ï¸ æ°¸è¿œçˆ±ä½ ";
                    } else if (isVictory) {
                        detectedGesture = 'gesture2';
                        newRomanticMode = false;
                        statusText = "âœŒï¸ æˆ‘";
                    } else if (extendedCount >= 4) {
                        detectedGesture = 'idle';
                        newRomanticMode = false;
                        statusText = "ğŸ–ï¸ æ•£å¼€";
                    } else {
                        detectedGesture = lastDetectedGesture;
                        statusText = "ğŸ–ï¸ " + (lastDetectedGesture === 'idle' ? "æ•£å¼€" : "ä¿æŒ...");
                    }
                }

                // Debounce
                if (detectedGesture === lastDetectedGesture) {
                    gestureStableCounter++;
                } else {
                    gestureStableCounter = 0;
                    lastDetectedGesture = detectedGesture;
                }

                if (gestureStableCounter >= GESTURE_STABLE_THRESHOLD && detectedGesture !== currentModel) {
                    changeModel(detectedGesture);
                    gestureStableCounter = 0;
                }

                isRomanticMode = newRomanticMode;

                const depthPercent = Math.round(handDepth * 100);
                updateStatus(statusText + ` [${depthPercent}%]`, true);
            } else {
                updateStatus('ğŸ”’ ä¿æŒå½“å‰çŠ¶æ€', false);
            }
        }

        function updateStatus(text, isActive) {
            const el = document.getElementById('status-text');
            if (el) el.textContent = text;
            const indicator = document.querySelector('.status-indicator');
            if (indicator) {
                if (currentModel === 'tree') {
                    const goldShimmer = Math.floor((time * 10) % 2);
                    indicator.style.background = goldShimmer ? '#ffd700' : '#10b981';
                } else {
                    indicator.style.background = isActive ? '#ff1493' : '#666';
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            updateParticlePositions();
            updateFloatingImages();

            const isTextMode = (currentModel === 'gesture1' || currentModel === 'gesture2' || currentModel === 'gesture3');

            if (currentModel === 'tree') {
                particles.rotation.y += CONFIG.rotationSpeed * 1.2;
                particles.rotation.x = 0;
                particles.position.x = 0;
                particles.position.y = Math.sin(time * 0.8) * 0.04;
                particles.position.z = 0;
            } else if (isTextMode) {
                particles.rotation.y = 0;
                // æ–‡å­—ä¸å†è·Ÿéšæ‰‹åŠ¿ç§»åŠ¨ï¼Œå›ºå®šåœ¨å±å¹•ä¸­å¿ƒ
                particles.rotation.x = 0;
                particles.position.x += (0 - particles.position.x) * 0.1;
                particles.position.y += (0 - particles.position.y) * 0.1;
                particles.position.z = 0;
            } else if (currentModel === 'heart') {
                particles.rotation.y = Math.sin(time) * 0.1;
                particles.rotation.x = 0;
                particles.position.x = 0;
                particles.position.y = 0;
                particles.position.z = 0;
            } else {
                particles.rotation.y += CONFIG.rotationSpeed;
                particles.rotation.x = 0;
                particles.position.x = 0;
                particles.position.y = 0;
                particles.position.z = 0;
            }

            // æ›´æ–°å…‰æ ‡ä½ç½®
            // æ›´æ–°å…‰æ ‡ä½ç½® - ç°åœ¨è·ŸéšæŒ‡å°–ä¸­å¿ƒ (Interaction Cursor)
            if (cursorMesh) {
                // ä½¿ç”¨æ›´çµæ•çš„ Lerpï¼Œå› ä¸ºæŒ‡å°–è¿åŠ¨å¿«
                cursorMesh.position.lerp(new THREE.Vector3(
                    // å¦‚æœ handPosition å’Œ interactionPos å·®å¼‚å¤§ï¼Œå¯èƒ½éœ€è¦æŠŠ interactionPos å­˜åˆ°å…¨å±€å˜é‡
                    // è¿™é‡Œæˆ‘ä»¬ç®€å•è¿‘ä¼¼ï¼Œæˆ–è€…éœ€è¦ä¿®æ”¹ onHandsResults æš´éœ² interactionX/Y
                    // ä½†ä¸ºäº†ç®€ä¾¿ï¼Œæˆ‘ä»¬è®©å…‰æ ‡ç»§ç»­è·Ÿéš handPosition (æ‰‹æŒ)ï¼Œ
                    // ä½†æ˜¯ï¼ä¸ºäº†"å‡†ç¡®"ï¼Œå…‰æ ‡å¿…é¡»æ˜¾ç¤ºäº¤äº’ç‚¹ã€‚
                    // è®©æˆ‘ä»¬åœ¨ update ä¸­æ— æ³•è·å¾— interactionX... 
                    // ä¿®æ”¹ï¼šåœ¨ onHandsResults ä¸­æ›´æ–° cursorMesh ä½ç½®æ›´åˆé€‚ï¼Œæˆ–è€…å­˜å…¨å±€ã€‚

                    // ä¸´æ—¶æ–¹æ¡ˆï¼šè®© cursorMesh åœ¨ onHandsResults ç›´æ¥æ›´æ–°ï¼Œè¿™é‡Œæ³¨é‡Šæ‰æˆ–è€…åªåšå¹³æ»‘
                    // ä¸ºäº†ä»£ç è¿è´¯æ€§ï¼Œæˆ‘ä»¬è¿˜æ˜¯ç”¨ handPositionï¼Œä½†æˆ‘ä»¬åœ¨ onHandsResults é‡ŒæŠŠ handPosition æ›´æ–°ä¸ºäº† interactionX?
                    // ä¸ï¼ŒhandPosition è¿˜æ˜¯ Palmã€‚
                    // è¿™é‡Œçš„ cursorMesh é€»è¾‘å…¶å®æœ‰ç‚¹å¤šä½™ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ js é‡Œæ²¡æ³•è·¨ä½œç”¨åŸŸæ‹¿åˆ° interactionXï¼Œé™¤é...
                    // è®©æˆ‘ä»¬å›é€€ä¸€ç‚¹æƒ³æ³•ï¼šå…‰æ ‡è¿˜æ˜¯è·Ÿéšæ‰‹æŒæ•´ä½“ç§»åŠ¨æ¯”è¾ƒç¨³ï¼Œä½†æ˜¯é€‰ä¸­åˆ¤å®šç”¨æŒ‡å°–ã€‚
                    // æˆ–è€…ï¼šæˆ‘ä»¬æŠŠ interactionX å­˜å…¥ global cursorTarget
                    cursorTarget.x, cursorTarget.y, 0
                ), 0.3);

                const scale = (currentModel === 'heart' || currentModel === 'gesture3') ? 0.5 : 1.0;
                cursorMesh.scale.setScalar(scale);
            }
            renderer.render(scene, camera);
        }

        async function init() {
            try {
                initThreeJS();
                await initMediaPipe();

                const loading = document.getElementById('loading');
                if (loading) loading.style.display = 'none';

                animate();
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        init();
    </script>
</body>

</html>