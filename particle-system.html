<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dç²’å­äº¤äº’ç³»ç»Ÿ - ARæ¨¡å¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }

        #video {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 320px;
            height: 180px;
            object-fit: cover;
            z-index: 10;
            transform: scaleX(-1);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        #status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(15px);
            padding: 14px 28px;
            border-radius: 30px;
            font-size: 15px;
            z-index: 100;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            font-weight: 500;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ade80;
            margin-right: 10px;
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.6);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.6;
                transform: scale(1.1);
            }
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 24px;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }
    </style>
</head>

<body>
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">æ­£åœ¨å¯åŠ¨ARæ¨¡å¼...</div>
    </div>

    <video id="video" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <div id="status">
        <span class="status-indicator"></span>
        <span id="status-text">åˆå§‹åŒ–ä¸­...</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>

    <script>
        const CONFIG = {
            particleCount: 15000,
            baseScale: 1.0,
            transitionSpeed: 0.15,
            rotationSpeed: 0.002,
            romanticColor: new THREE.Color('#ff1493'),
            normalColor: new THREE.Color('#667eea'),
            treeGreenColor: new THREE.Color('#10b981'),
            treeGoldColor: new THREE.Color('#fbbf24'),
            treeRedColor: new THREE.Color('#ef4444'),
            treeSilverColor: new THREE.Color('#e5e7eb'),
            treeBrownColor: new THREE.Color('#92400e'),
            coinGoldColor: new THREE.Color('#ffd700')
        };

        function createTextParticles(text, count) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 600;
            const height = 300;
            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            ctx.font = 'bold 120px "Microsoft YaHei", "Heiti SC", sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const validPixels = [];

            for (let y = 0; y < height; y += 3) {
                for (let x = 0; x < width; x += 3) {
                    const i = (y * width + x) * 4;
                    if (data[i] > 50) {
                        validPixels.push({
                            x: (x - width / 2) / 80,
                            y: -(y - height / 2) / 80
                        });
                    }
                }
            }

            const positions = [];
            for (let i = 0; i < count; i++) {
                if (validPixels.length > 0) {
                    const pixel = validPixels[Math.floor(Math.random() * validPixels.length)];
                    positions.push(
                        pixel.x + (Math.random() - 0.5) * 0.05,
                        pixel.y + (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.2
                    );
                } else {
                    const theta = Math.random() * Math.PI * 2;
                    const r = 2 * Math.random();
                    positions.push(r * Math.cos(theta), r * Math.sin(theta), (Math.random() - 0.5) * 0.5);
                }
            }
            return new Float32Array(positions);
        }

        const Models = {
            idle: (count) => {
                const positions = [];
                for (let i = 0; i < count; i++) {
                    positions.push(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 12,
                        (Math.random() - 0.5) * 10
                    );
                }
                return new Float32Array(positions);
            },
            heart: (count) => {
                const positions = [];
                for (let i = 0; i < count; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.pow(Math.random(), 0.5);
                    const depth = (Math.random() - 0.5);
                    const heartX = 16 * Math.pow(Math.sin(t), 3);
                    const heartY = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    const scale = 0.08;
                    const thicknessScale = 0.8;
                    positions.push(
                        heartX * r * scale,
                        heartY * r * scale,
                        depth * thicknessScale * (1 - r * 0.3)
                    );
                }
                return new Float32Array(positions);
            },
            tree: (count) => {
                const positions = [];
                const trunkCount = Math.floor(count * 0.04);
                for (let i = 0; i < trunkCount; i++) {
                    const h = Math.random() * 0.3;
                    const angle = Math.random() * Math.PI * 2;
                    const r = 0.12 + Math.random() * 0.08;
                    positions.push(r * Math.cos(angle), h - 2.0, r * Math.sin(angle));
                }
                const mainTreeCount = Math.floor(count * 0.53); // å¢åŠ ä¸»æ ‘å¹²æ¯”ä¾‹ï¼Œå‡å°‘æ ‘é¡¶çš„æ‹¥æŒ¤æ„Ÿ
                for (let i = 0; i < mainTreeCount; i++) {
                    const h = Math.random();
                    const layer = Math.floor(h * 7);
                    const layerH = layer / 7;
                    const layerOffset = (h - layerH) * 7;
                    const angle = h * Math.PI * 18 + Math.random() * Math.PI / 4;
                    const baseR = (1 - layerH) * 2.3;
                    const waveR = Math.sin(layerOffset * Math.PI) * 0.35;
                    const r = (baseR + waveR) * (0.85 + Math.random() * 0.3);
                    const radialPos = Math.pow(Math.random(), 0.6);
                    positions.push(
                        r * radialPos * Math.cos(angle) * 0.6,
                        h * 4.2 - 1.7,
                        r * radialPos * Math.sin(angle) * 0.6
                    );
                }
                const ornamentCount = Math.floor(count * 0.12);
                const ornamentClusters = 25;
                for (let i = 0; i < ornamentCount; i++) {
                    const clusterIdx = Math.floor(Math.random() * ornamentClusters);
                    const clusterH = 0.15 + (clusterIdx / ornamentClusters) * 0.7;
                    const clusterAngle = (clusterIdx * 2.4) % (Math.PI * 2);
                    const clusterR = (1 - clusterH) * 2.0;
                    const cx = clusterR * Math.cos(clusterAngle) * 0.6;
                    const cy = clusterH * 4.2 - 1.7;
                    const cz = clusterR * Math.sin(clusterAngle) * 0.6;
                    const clusterSize = 0.12;
                    positions.push(
                        cx + (Math.random() - 0.5) * clusterSize,
                        cy + (Math.random() - 0.5) * clusterSize,
                        cz + (Math.random() - 0.5) * clusterSize
                    );
                }
                const lightCount = Math.floor(count * 0.08);
                for (let i = 0; i < lightCount; i++) {
                    const h = 0.1 + Math.random() * 0.85;
                    const angle = Math.random() * Math.PI * 2;
                    const r = (1 - h) * 2.3 * 1.08;
                    positions.push(r * Math.cos(angle) * 0.6, h * 4.2 - 1.7, r * Math.sin(angle) * 0.6);
                }
                const coinCount = Math.floor(count * 0.20);
                for (let i = 0; i < coinCount; i++) {
                    const spiralLayer = Math.floor(Math.random() * 3);
                    const spiralRadius = 2.8 + spiralLayer * 0.8;
                    const spiralH = Math.random();
                    const spiralAngle = Math.random() * Math.PI * 2;
                    const coinX = spiralRadius * Math.cos(spiralAngle) * 0.7;
                    const coinY = spiralH * 5.5 - 2.5;
                    const coinZ = spiralRadius * Math.sin(spiralAngle) * 0.7;
                    positions.push(
                        coinX + (Math.random() - 0.5) * 0.3,
                        coinY,
                        coinZ + (Math.random() - 0.5) * 0.3
                    );
                }
                const tipCount = count - trunkCount - mainTreeCount - ornamentCount - lightCount - coinCount;
                for (let i = 0; i < tipCount; i++) {
                    const h = Math.random();
                    // é£æ ¼ç»Ÿä¸€ï¼šä¸å†æ˜¯å®Œç¾çš„åœ†é”¥ï¼Œè€Œæ˜¯å¸¦æœ‰èºæ—‹å’ŒéšæœºæŠ–åŠ¨çš„è‡ªç„¶æ ‘å°–
                    // æ¨¡ä»¿æ ‘èº«çš„ç”Ÿé•¿é€»è¾‘ï¼Œèºæ—‹ä¸Šå‡
                    const y = 2.4 + h * 0.6; // å»¶ä¼¸åˆ° 3.0

                    // åŠå¾„è¡°å‡ï¼Œå‡å°åŠå¾„è®©å…¶æ›´æ¸…çˆ½ï¼Œä¸é‚£ä¹ˆ"æ»¡"
                    const baseR = (1 - h) * 0.22;
                    const r = baseR * (0.8 + Math.random() * 0.4); // éšæœºæŠ–åŠ¨

                    const angle = h * Math.PI * 10 + Math.random() * Math.PI * 2;

                    positions.push(
                        r * Math.cos(angle),
                        y,
                        r * Math.sin(angle)
                    );
                }
                return new Float32Array(positions);
            },
            gesture3: (count) => createTextParticles("å¤§å¤´èœèœ", count),
            gesture2: (count) => createTextParticles("æˆ‘", count),
            gesture1: (count) => createTextParticles("å–œæ¬¢ä½ ", count)
        };

        let scene, camera, renderer, particles;
        let cursorMesh;
        let currentModel = 'idle';
        let targetPositions, currentPositions;
        let currentScale = CONFIG.baseScale;
        let isRomanticMode = false;
        let time = 0;

        let handPosition = { x: 0, y: 0, z: 0 };
        let handVelocity = { x: 0, y: 0 };
        let prevHandPosition = { x: 0, y: 0 };

        let handDepth = 1.0;
        let targetDepth = 1.0;

        // é—®é¢˜3è§£å†³ï¼šæ‰‹åŠ¿ç¨³å®šæ€§æ£€æµ‹
        let gestureStableCounter = 0;
        let lastDetectedGesture = 'idle';
        const GESTURE_STABLE_THRESHOLD = 8;

        let particleColors;

        const IMAGE_URLS = [
            'https://picsum.photos/id/237/200/300',
            'https://picsum.photos/id/10/200/300',
            'https://picsum.photos/id/1015/200/300',
            'https://picsum.photos/id/1016/200/300',
            'https://picsum.photos/id/1020/200/300',
            'https://picsum.photos/id/1025/200/300'
        ];

        let floatingImages = [];
        let imageGroup;

        function createFloatingImages() {
            imageGroup = new THREE.Group();
            scene.add(imageGroup);

            const loader = new THREE.TextureLoader();

            IMAGE_URLS.forEach((url, i) => {
                const texture = loader.load(url);
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.9
                });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(0.4, 0.6, 1);
                sprite.userData = {
                    id: i,
                    angleOffset: (i / IMAGE_URLS.length) * Math.PI * 2,
                    isSelected: false,
                    targetScale: 0.4
                };
                imageGroup.add(sprite);
                floatingImages.push(sprite);
            });
        }

        // ä¼˜åŒ–ï¼šç…§ç‰‡å…‰æ™•å’Œä¸æ»‘å‡ºåœº
        // ä¼˜åŒ–ï¼šç…§ç‰‡å…‰æ™•å’Œä¸æ»‘å‡ºåœº
        function updateFloatingImages() {
            if (!imageGroup) return;
            const t = time * 0.5;

            floatingImages.forEach((sprite, i) => {
                let targetPos = new THREE.Vector3();
                // é€‰ä¸­æ—¶æ”¾å¤§ï¼Œä¸”æœ‰å…‰æ™•(é€šè¿‡ç¼©æ”¾æ¨¡æ‹Ÿæˆ–shader)
                let targetScale = sprite.userData.isSelected ? 2.5 : 0.0; // é»˜è®¤éšè—æˆ–æå°ï¼Œå‡ºç°åœ¨ç²’å­ä¸­

                // è®©ç…§ç‰‡æ··åœ¨ç²’å­ä¸­
                if (currentModel === 'tree') {
                    // æŒ‚åœ¨æ ‘ä¸Šçš„ä½ç½®
                    const angle = sprite.userData.angleOffset + t * 0.2;
                    const r = 1.5 - (i / floatingImages.length) * 0.8;
                    targetPos.set(Math.cos(angle) * r, 1.0 - (i / floatingImages.length) * 2.5, Math.sin(angle) * r);

                    // é—®é¢˜3è§£å†³ï¼šèšæˆåœ£è¯æ ‘æ—¶ï¼Œå°†å›¾ç‰‡å†ç¼©å°ä¸€ç‚¹ (0.18 -> 0.12)
                    if (!sprite.userData.isSelected) targetScale = 0.12;

                } else if (sprite.userData.isSelected) {
                    targetPos.set(0, 0, 1.0); // å±…ä¸­
                } else {
                    // éšè—åœ¨ç²’å­äº‘ä¸­
                    const pIdx = Math.floor(i * (CONFIG.particleCount / floatingImages.length));
                    const positions = particles.geometry.attributes.position.array;
                    if (positions && positions.length > pIdx * 3 + 2) {
                        targetPos.set(
                            positions[pIdx * 3],
                            positions[pIdx * 3 + 1],
                            positions[pIdx * 3 + 2]
                        );
                    }
                    targetScale = 0.0; // è¿˜æ²¡å±•ç¤ºæ—¶éšè—
                }

                // Spring physics / Smooth Lerp
                sprite.position.lerp(targetPos, 0.08);

                const currentS = sprite.scale.x;
                const newS = currentS + (targetScale - currentS) * 0.1;
                sprite.scale.set(newS, newS * 1.5, 1);

                // ç®€å•çš„å…‰æ™•æ•ˆæœï¼šè°ƒæ•´æè´¨opacityå’Œcolor
                if (sprite.userData.isSelected) {
                    sprite.material.opacity = 1.0;
                } else {
                    sprite.material.opacity = 0.8;
                }
            });
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = null;

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3.5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createParticleSystem();
            createFloatingImages();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            // åˆ›å»ºå…‰æ ‡ - é—®é¢˜2è§£å†³ï¼šå»é™¤å±å¹•ä¸­é—´çš„åœ†åœˆ
            // const cursorGeometry = new THREE.RingGeometry(0.08, 0.1, 32);
            // const cursorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
            // cursorMesh = new THREE.Mesh(cursorGeometry, cursorMaterial);
            // scene.add(cursorMesh);

            window.addEventListener('resize', onWindowResize);
        }

        // ç”Ÿæˆç²’å­çº¹ç†å›¾é›†
        function createTextureAtlas() {
            const canvas = document.createElement('canvas');
            const size = 1024; // 256px per cell * 4
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);

            const cellSize = 256;
            const icons = [
                'âšª', // 0: Default
                'ğŸ', // 1: Gift
                'ğŸ§¦', // 2: Sock
                'ğŸ””', // 3: Bell
                'ğŸ‘”', // 4: Tie
                'ğŸ”º', // 5: Triangle
                'ğŸ„', // 6: Tree
                'ğŸ…', // 7: Santa
                'ğŸª™', // 8: Coin
                'â­', // 9: Star (Custom Draw)
                'â„ï¸', // 10: Snowflake
                'â¤ï¸', // 11: Heart
                'â›„', // 12: Snowman
                'âœ¨', // 13: Sparkles
                'ğŸ”´', // 14: Sphere
                'ğŸŸ©'  // 15: Cube
            ];

            ctx.font = '180px apple color emoji, segoe ui emoji, notocolor emoji';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < 16; i++) {
                const x = (i % 4) * cellSize;
                const y = Math.floor(i / 4) * cellSize;
                const cx = x + cellSize / 2;
                const cy = y + cellSize / 2;

                // Draw icon
                if (i === 0) {
                    // Draw a nice gradient circle for default
                    const grad = ctx.createRadialGradient(cx, cy, 10, cx, cy, 110);
                    grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                    grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 110, 0, Math.PI * 2);
                    ctx.fill();
                } else if (i === 9) {
                    // é—®é¢˜1è§£å†³ï¼šæ‰‹ç»˜äº”è§’æ˜Ÿ
                    // ç”¨æˆ·åé¦ˆï¼šè¦æ ‡å‡†çš„äº”è§’æ˜Ÿï¼Œä¸è¦å¤ªèƒ–åƒäº”è¾¹å½¢
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.beginPath();
                    const outerRadius = 110;
                    const innerRadius = 45;  // è°ƒå›æ ‡å‡†æ¯”ä¾‹ (approx 0.4 of outer)ï¼Œå˜å°–

                    // æ—‹è½¬ä¿®æ­£ï¼Œè®©ä¸€ä¸ªè§’å‚ç›´å‘ä¸Š
                    ctx.rotate(-Math.PI / 2); // -90åº¦ï¼Œè§’æœä¸Š

                    for (let n = 0; n < 5; n++) {
                        const angleOuter = (n * Math.PI * 2) / 5;
                        const angleInner = ((n + 0.5) * Math.PI * 2) / 5;

                        // Outer Point
                        if (n === 0) ctx.moveTo(Math.cos(angleOuter) * outerRadius, Math.sin(angleOuter) * outerRadius);
                        else ctx.lineTo(Math.cos(angleOuter) * outerRadius, Math.sin(angleOuter) * outerRadius);

                        // Inner Point
                        ctx.lineTo(Math.cos(angleInner) * innerRadius, Math.sin(angleInner) * innerRadius);
                    }
                    ctx.closePath();

                    // æŸ”å’Œçš„æš–è‰²æ¸å˜
                    const starGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 100);
                    starGrad.addColorStop(0, '#fffbe6'); // ä¸­å¿ƒç”šè‡³æœ‰ç‚¹ç™½
                    starGrad.addColorStop(0.4, '#ffd700'); // é‡‘è‰²
                    starGrad.addColorStop(1, '#ff8c00');   // è¾¹ç¼˜æ©™è‰²

                    ctx.fillStyle = starGrad;

                    // åœ†è§’è¿æ¥ï¼Œä¿æŒä¸€ç‚¹ç‚¹åœ†æ¶¦æ„Ÿï¼Œä½†ä¸è‡³äºå˜æˆçƒ
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.lineWidth = 8; // çº¿æ¡å‡ç»†ä¸€ç‚¹ï¼Œé¿å…è®©è§’æ˜¾å¾—å¤ªé’
                    ctx.strokeStyle = '#ffd700';
                    ctx.stroke();
                    ctx.fill();

                    ctx.restore();
                } else {
                    const icon = icons[i] || 'â“';
                    ctx.fillText(icon, cx, cy + 10);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.flipY = false;
            return texture;
        }

        // é¡¶ç‚¹ç€è‰²å™¨
        const vertexShader = `
            attribute float size;
            attribute vec3 customColor;
            attribute float shapeIndex;
            varying vec3 vColor;
            varying float vShapeIndex;
            varying vec3 vPosition;
            varying float vAlpha;
            uniform float uTime;
            uniform float uScale;
            uniform float uHandDepth;

            void main() {
                vColor = customColor;
                vShapeIndex = shapeIndex;
                vPosition = position;
                
                // ä¸æ»‘çš„å‘¼å¸æ•ˆæœ
                float pulse = 1.0 + 0.1 * sin(uTime * 2.0 + position.x * 2.0);
                
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                // å¤§å°éšæ·±åº¦å’Œå‘¼å¸å˜åŒ–
                float depthScale = smoothstep(5.0, 1.0, -mvPosition.z); // è¿‘å¤§è¿œå°ä¼˜åŒ–
                gl_PointSize = size * uScale * uHandDepth * pulse * (400.0 / -mvPosition.z);
                
                // è¾¹ç¼˜æ¸éš
                vAlpha = min(1.0, 1.5 - length(position.xy) / 8.0);
            }
        `;

        // ç‰‡å…ƒç€è‰²å™¨ - æ”¯æŒå›¾é›†å’Œåå…‰
        const fragmentShader = `
            uniform sampler2D uTexture;
            uniform float uTime;
            varying vec3 vColor;
            varying float vShapeIndex;
            varying float vAlpha;

            void main() {
                float index = floor(vShapeIndex + 0.5);
                vec2 uv = gl_PointCoord;
                
                // æ˜Ÿæ˜Ÿ(Index 9)è‡ªè½¬é€»è¾‘ï¼šä¸åœ£è¯æ ‘åæ–¹å‘æ—‹è½¬
                // åœ£è¯æ ‘æ˜¯ç»•Yè½´è½¬ï¼Œæ˜Ÿæ˜Ÿä½œä¸º2Dè´´å›¾ï¼Œæˆ‘ä»¬è®©å®ƒè¿›è¡Œ2Dè‡ªè½¬æ¥å®ç°è§†è§‰ä¸Šçš„æ—‹è½¬æ„Ÿ
                if (abs(index - 9.0) < 0.1) {
                     vec2 center = vec2(0.5);
                     // æ ‘æ˜¯é¡ºæ—¶é’ˆ(æ­£å‘angle)ï¼Œæ˜Ÿæ˜Ÿå°±é€†æ—¶é’ˆ(è´Ÿå‘angle)
                     // è°ƒæ•´é€Ÿåº¦è®©å®ƒçœ‹èµ·æ¥ä¼˜é›…
                     float angle = uTime * 1.0; 
                     float s = sin(angle);
                     float c = cos(angle);
                     vec2 centered = uv - center;
                     // æ—‹è½¬çŸ©é˜µ
                     uv = vec2(
                         centered.x * c - centered.y * s,
                         centered.x * s + centered.y * c
                     ) + center;
                     
                     // æ—‹è½¬åå¦‚æœè¶…å‡º[0,1]èŒƒå›´åˆ™ä¸¢å¼ƒï¼Œé˜²æ­¢æ˜¾ç¤ºå‡ºé‚»è¿‘çš„å›¾æ ‡
                     if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) discard;
                }

                // è®¡ç®—å½“å‰ç²’å­åœ¨å›¾é›†ä¸­çš„UV
                float col = mod(index, 4.0);
                float row = 3.0 - floor(index / 4.0); // flipY handled in JS, but grid is top-down usually
                
                // æ˜ å°„åˆ°å›¾é›†åæ ‡
                vec2 finalUV = uv;
                finalUV.x = (finalUV.x + col) / 4.0;
                finalUV.y = (finalUV.y + row) / 4.0;

                vec4 texColor = texture2D(uTexture, finalUV);
                
                if (texColor.a < 0.1) discard;

                // åå…‰æ•ˆæœ (Sheen)
                float sheen = 0.0;
                if (index > 0.5) { // å¯¹Emojiæ·»åŠ æµå…‰
                     // æ˜Ÿæ˜Ÿçš„æµå…‰ä¹Ÿè·Ÿéšæ—‹è½¬ç¨å¾®å˜åŠ¨ä¸€ä¸‹
                     float sheenPos = (uv.x + uv.y) * 3.0 - uTime * 3.0;
                     sheen = max(0.0, sin(sheenPos)) * 0.3;
                }

                // æ˜Ÿæ˜Ÿ(index 9)å‘å…‰ç‰¹æ•ˆ
                vec3 finalColor = vColor + sheen;
                float alpha = texColor.a * vAlpha * 0.95;

                if (abs(index - 9.0) < 0.1) {
                    // æ˜Ÿæ˜Ÿå‘å…‰å¢å¼º
                    float glow = 0.5 + 0.5 * sin(uTime * 3.0); // å¼ºçƒˆçš„å‘¼å¸å…‰
                    finalColor += vec3(0.5, 0.4, 0.1) * glow; // é‡‘è‰²å…‰æ™•å åŠ 
                    
                    // æ ¸å¿ƒæ›´äº®
                    finalColor *= 1.5;
                }

                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            targetPositions = Models[currentModel](CONFIG.particleCount);
            currentPositions = new Float32Array(targetPositions); // Start positions

            // åˆå§‹åŒ– buffer
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(CONFIG.particleCount * 3), 3));
            geometry.getAttribute('position').set(currentPositions); // Set initial

            particleColors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            const shapeIndices = new Float32Array(CONFIG.particleCount);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                particleColors[i * 3] = CONFIG.normalColor.r;
                particleColors[i * 3 + 1] = CONFIG.normalColor.g;
                particleColors[i * 3 + 2] = CONFIG.normalColor.b;
                sizes[i] = 0.05 + Math.random() * 0.05; // åŸºç¡€å¤§å°

                // éšæœºåˆ†é…å½¢çŠ¶ï¼Œåœ†å½¢(0)æ¦‚ç‡æœ€é«˜
                const r = Math.random();
                if (r < 0.6) shapeIndices[i] = 0; // åœ†å½¢
                else if (r < 0.65) shapeIndices[i] = 1; // ç¤¼ç‰©
                else if (r < 0.68) shapeIndices[i] = 2; // è¢œå­
                else if (r < 0.71) shapeIndices[i] = 3; // é“ƒé“›
                else if (r < 0.74) shapeIndices[i] = 4; // é¢†å¸¦
                else if (r < 0.77) shapeIndices[i] = 5; // ä¸‰è§’å½¢
                else if (r < 0.80) shapeIndices[i] = 7; // åœ£è¯è€äºº
                else if (r < 0.83) shapeIndices[i] = 8; // é‡‘å¸
                else if (r < 0.86) shapeIndices[i] = 10; // é›ªèŠ±
                else if (r < 0.89) shapeIndices[i] = 12; // é›ªäºº
                else if (r < 0.92) shapeIndices[i] = 13; // é—ªå…‰
                else shapeIndices[i] = 9; // æ˜Ÿæ˜Ÿ
            }

            // å¼ºåˆ¶è®¾ç½®æ ‘é¡¶æ˜Ÿæ˜Ÿ (å¦‚æœéœ€è¦ç‰¹å®šID)
            // è¿™é‡Œæˆ‘ä»¬å°†åœ¨ update ä¸­åŠ¨æ€è°ƒæ•´æ ‘é¡¶ç²’å­çš„å½¢çŠ¶ï¼Œä½†å…ˆé¢„è®¾ä¸€ä¸ªåˆå§‹å€¼
            // å°†æœ€åä¸€ä¸ªç²’å­ä½œä¸ºæ˜Ÿæ˜Ÿ

            geometry.setAttribute('customColor', new THREE.BufferAttribute(particleColors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('shapeIndex', new THREE.BufferAttribute(shapeIndices, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uScale: { value: 1.0 },
                    uHandDepth: { value: 1.0 },
                    uTexture: { value: createTextureAtlas() }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                // è§£å†³æ˜Ÿæ˜Ÿå¯èƒ½è¢«æˆªæ–­çš„é—®é¢˜ï¼Œå°è¯•ç¦ç”¨å‰”é™¤æˆ–è€…ä¸å®Œå…¨ä¾èµ– FrustumCulling (å°½ç®¡ Points é»˜è®¤å°±æœ‰)
            });

            particles = new THREE.Points(geometry, material);
            // è°ƒæ•´ç›¸æœºä½ç½®æˆ–è€…æ¨¡å‹æ•´ä½“ä½ç½®ï¼Œç¡®ä¿æ˜Ÿæ˜Ÿå¯è§
            // æˆ–è€…åœ¨æ¨¡å‹ç”Ÿæˆæ—¶è°ƒæ•´é«˜åº¦ã€‚è¿™é‡Œæˆ‘ä»¬å¾®è°ƒä¸€ä¸‹ç›¸æœº
            camera.position.y = 0.5; // ç¨å¾®æŠ¬é«˜ç›¸æœº

            scene.add(particles);

            // ç¡®ä¿æ–‡å­—ç²’å­æ¨¡å¼åˆå§‹ä½ç½®æ­£ç¡®
            // ... (positions are already in targetPositions)
        }

        function updateParticlePositions() {
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.customColor.array; // Shader uses customColor
            const shapes = particles.geometry.attributes.shapeIndex.array;
            const sizes = particles.geometry.attributes.size.array;

            const isTextMode = (currentModel === 'gesture1' || currentModel === 'gesture2' || currentModel === 'gesture3');

            // ä¸æ»‘æ’å€¼å› å­
            const lerpFactor = 0.08;

            for (let i = 0; i < positions.length; i += 3) {
                let targetX = targetPositions[i] * currentScale;
                let targetY = targetPositions[i + 1] * currentScale;
                let targetZ = targetPositions[i + 2] * currentScale;



                positions[i] += (targetX - positions[i]) * lerpFactor;
                positions[i + 1] += (targetY - positions[i + 1]) * lerpFactor;
                positions[i + 2] += (targetZ - positions[i + 2]) * lerpFactor;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.shapeIndex.needsUpdate = true;
            particles.geometry.attributes.size.needsUpdate = true;

            // Update Uniforms
            particles.material.uniforms.uTime.value = time;
            particles.material.uniforms.uHandDepth.value = handDepth * (isRomanticMode ? 1.1 : 1.0);

            // Color Logic (Optimized)
            if (currentModel === 'tree') {
                const pCount = CONFIG.particleCount;
                // Simple gradient logic based on index for simplicity & performance
                for (let i = 0; i < pCount; i++) {
                    // Removed obsolete star skip

                    let targetColor = CONFIG.treeGreenColor;
                    if (shapes[i] === 1 || shapes[i] === 7) targetColor = CONFIG.treeRedColor; // Gift/Santa
                    else if (shapes[i] === 8 || shapes[i] === 3) targetColor = CONFIG.coinGoldColor; // Coin/Bell
                    else if (shapes[i] === 2) targetColor = CONFIG.treeSilverColor; // Sock

                    if (shapes[i] !== 0 && shapes[i] !== 6) { // Special items should pop
                        // Slight flash
                        targetColor = targetColor.clone().lerp(new THREE.Color(1, 1, 1), 0.2 * Math.sin(time * 5 + i));
                    }

                    // Trunk logic (bottom particles roughly) - simplified for stability
                    if (targetPositions[i * 3 + 1] < -1.5 && Math.abs(targetPositions[i * 3]) < 0.5) {
                        targetColor = CONFIG.treeBrownColor;
                        shapes[i] = 0; // Force trunk to dots
                    }

                    // Tree Tip logic is removed to allow random particles

                    colors[i * 3] += (targetColor.r - colors[i * 3]) * 0.05;
                    colors[i * 3 + 1] += (targetColor.g - colors[i * 3 + 1]) * 0.05;
                    colors[i * 3 + 2] += (targetColor.b - colors[i * 3 + 2]) * 0.05;
                }
            } else {
                let targetColor = CONFIG.normalColor;
                if (currentModel === 'heart' || currentModel === 'gesture1') targetColor = CONFIG.romanticColor;

                for (let i = 0; i < CONFIG.particleCount; i++) {
                    colors[i * 3] += (targetColor.r - colors[i * 3]) * 0.05;
                    colors[i * 3 + 1] += (targetColor.g - colors[i * 3 + 1]) * 0.05;
                    colors[i * 3 + 2] += (targetColor.b - colors[i * 3 + 2]) * 0.05;
                }
            }
            particles.geometry.attributes.customColor.needsUpdate = true;
        }

        function changeModel(modelName) {
            if (currentModel !== modelName && Models[modelName]) {
                currentModel = modelName;
                targetPositions = Models[modelName](CONFIG.particleCount);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let hands;

        async function initMediaPipe() {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandsResults);

            const videoElement = document.getElementById('video');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720, facingMode: 'user' }
                });
                videoElement.srcObject = stream;
                await new Promise(resolve => videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    resolve();
                });

                async function sendFrame() {
                    await hands.send({ image: videoElement });
                    requestAnimationFrame(sendFrame);
                }
                sendFrame();
                updateStatus('ğŸ¥ ARæ¨¡å¼å°±ç»ª - è¯·å±•ç¤ºæ‰‹åŠ¿', true);
            } catch (error) {
                console.error('æ‘„åƒå¤´é”™è¯¯:', error);
                updateStatus('æ‘„åƒå¤´è®¿é—®å¤±è´¥', false);
            }
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                const palm = landmarks[9];
                const newX = -(palm.x - 0.5) * 4;
                const newY = -(palm.y - 0.5) * 3;

                const thumbTip = landmarks[4];
                const pinkyTip = landmarks[20];
                const handWidth = Math.sqrt(
                    Math.pow(thumbTip.x - pinkyTip.x, 2) +
                    Math.pow(thumbTip.y - pinkyTip.y, 2)
                );

                targetDepth = Math.max(0.5, Math.min(2.0, handWidth * 4));
                handDepth += (targetDepth - handDepth) * 0.1;

                handVelocity.x = newX - prevHandPosition.x;
                handVelocity.y = newY - prevHandPosition.y;
                prevHandPosition.x = newX;
                prevHandPosition.y = newY;
                handPosition.x = newX;
                handPosition.y = newY;

                const indexTip = landmarks[8];
                const thumbIp = landmarks[3];

                // --- å›¾ç‰‡äº¤äº’é€»è¾‘ ---
                // ä½¿ç”¨æ‰‹æŒä¸­å¿ƒä½œä¸ºå…‰æ ‡ä½ç½®ï¼Œæ›´ç¨³å®š
                const cursorX = handPosition.x;
                const cursorY = handPosition.y;

                let interactingImage = null;
                if (floatingImages) {
                    let minDist = 100;
                    floatingImages.forEach(sprite => {
                        sprite.userData.isSelected = false; // Reset
                        const dist = Math.sqrt(
                            Math.pow(sprite.position.x - cursorX, 2) +
                            Math.pow(sprite.position.y - cursorY, 2)
                        );
                        // é—®é¢˜4è§£å†³ï¼šç°åœ¨å¾ˆå®¹æ˜“è¯¯è§¦ï¼Œç¼©å°åˆ¤å®šèŒƒå›´ (0.5 -> 0.3)
                        if (dist < 0.3 && dist < minDist) {
                            minDist = dist;
                            interactingImage = sprite;
                        }
                    });
                }

                // é—®é¢˜1è§£å†³ï¼šæ”¹è¿›æ‰‹åŠ¿è¯†åˆ« - ä½¿ç”¨è·ç¦»è€Œéå•çº¯åæ ‡ï¼Œæ›´ç¨³å¥
                const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                const wrist = landmarks[0];

                // ä½¿ç”¨ handWidth ä½œä¸ºåŸºå‡†å°ºåº¦ (handWidth = distance(thumbTip, pinkyTip))
                // æ³¨æ„ï¼šhandWidth ä¼šéšç€æ‰‹åŠ¿å˜åŒ–ï¼ˆç‰¹åˆ«æ˜¯æ¡æ‹³ï¼‰ï¼Œæ‰€ä»¥ç”¨æ‰‹æŒå°ºåº¦æ›´ç¨³å®š
                // ä½¿ç”¨ Wrist(0) åˆ° MiddleMCP(9) çš„è·ç¦»ä½œä¸ºåŸºå‡†å°ºåº¦
                const palmScale = dist(landmarks[0], landmarks[9]);

                // ç®€å•çš„æ‰‹æŒ‡ä¼¸å±•æ£€æµ‹ï¼šæŒ‡å°–åˆ°æ‰‹è…•è·ç¦» > æŒ‡å…³èŠ‚åˆ°æ‰‹è…•è·ç¦» * é˜ˆå€¼
                const isExtended = (tipIdx, pipIdx) => dist(landmarks[tipIdx], wrist) > dist(landmarks[pipIdx], wrist) * 1.05; // ç¨å¾®æ”¾å®½ä¸€ç‚¹é˜ˆå€¼

                // æ‹‡æŒ‡ä¼¸å±•æ£€æµ‹:
                // 1. æ‹‡æŒ‡å°–(4) åˆ° å°æŒ‡æ ¹(17) çš„è·ç¦»è¶³å¤Ÿå¤§ (ç›¸å¯¹äºæ‰‹æŒ)
                // 2. æ‹‡æŒ‡å°–(4) åˆ° é£ŸæŒ‡æ ¹(5) çš„è·ç¦»è¶³å¤Ÿå¤§ (é¿å…è´´åœ¨é£ŸæŒ‡ä¸Š)
                const isThumbExtended = dist(landmarks[4], landmarks[17]) > palmScale * 1.2 && dist(landmarks[4], landmarks[5]) > palmScale * 0.3;

                const isIndexExt = isExtended(8, 6);
                const isMiddleExt = isExtended(12, 10);
                const isRingExt = isExtended(16, 14);
                const isPinkyExt = isExtended(20, 18);

                const extendedCount = [isIndexExt, isMiddleExt, isRingExt, isPinkyExt].filter(Boolean).length;

                // æåˆæ£€æµ‹ - è·ç¦»é˜ˆå€¼åŸºäºæ‰‹æŒå°ºåº¦
                const pinchDist = dist(landmarks[4], landmarks[8]);
                const isPinch = pinchDist < palmScale * 0.25;

                // æ£€æŸ¥æ˜¯å¦åœ¨äº¤äº’å›¾ç‰‡
                let isImageInteraction = false;
                if (interactingImage && isPinch) {
                    interactingImage.userData.isSelected = true;
                }

                let detectedGesture = 'idle';
                let statusText = "ğŸ–ï¸ æ•£å¼€";
                let newRomanticMode = isRomanticMode;

                if (isImageInteraction) {
                    detectedGesture = currentModel;
                    statusText = "ğŸ–¼ï¸ æŸ¥çœ‹ç…§ç‰‡";
                    newRomanticMode = isRomanticMode;
                }
                // å®½æ¾çš„å¼¯æ›²æ£€æµ‹ï¼šå…è®¸æ‰‹æŒ‡ç¨å¾®æ”¾æ¾ä¸€ç‚¹ä¹Ÿèƒ½è¢«è§†ä¸ºå¼¯æ›²
                // å¦‚æœæŒ‡å°–è·ç¦»æ‰‹è…• ä»…æ¯” æŒ‡å…³èŠ‚è·ç¦»æ‰‹è…• å¤šä¸€ç‚¹ç‚¹(æˆ–è€…æ›´å°‘)ï¼Œå°±ç®—å¼¯æ›²
                // ä¹‹å‰çš„ Extended æ˜¯ > 1.05ï¼Œè¿™é‡Œ Curled åªè¦ < 1.35 å°±è¡Œï¼Œç»™ä¸€ä¸ªè¾ƒå¤§çš„å®½å®¹åº¦
                const isCurled = (tipIdx, pipIdx) => dist(landmarks[tipIdx], wrist) < dist(landmarks[pipIdx], wrist) * 1.35;

                // æåˆæ—¶çš„çŠ¶æ€åŒºåˆ†
                if (isPinch) {
                    if (isMiddleExt && isRingExt && isPinkyExt) {
                        detectedGesture = 'gesture3'; // OKæ‰‹åŠ¿ -> å¤§å¤´èœèœ
                        newRomanticMode = false;
                        statusText = "ğŸ‘Œ å¤§å¤´èœèœ";
                    } else if (isCurled(12, 10) && isCurled(16, 14) && isCurled(20, 18)) {
                        // åªæœ‰å½“å…¶ä»–æ‰‹æŒ‡éƒ½æ¯”è¾ƒæ˜ç¡®å¼¯æ›²æ—¶æ‰ç®—çˆ±å¿ƒï¼Œé¿å…è¯¯è§¦
                        detectedGesture = 'heart'; // æ¯”å¿ƒ
                        newRomanticMode = true;
                        statusText = "â¤ï¸ çˆ±å¿ƒ";
                    } else if (!isMiddleExt && !isRingExt && !isPinkyExt) {
                        // å¤‡ç”¨åˆ¤å®šï¼šå¦‚æœéƒ½ä¸ç®—ä¼¸ç›´
                        detectedGesture = 'heart';
                        newRomanticMode = true;
                        statusText = "â¤ï¸ çˆ±å¿ƒ";
                    } else {
                        // æ¨¡ç³ŠçŠ¶æ€ï¼Œä¿æŒä¸Šä¸€æ¬¡
                        detectedGesture = lastDetectedGesture;
                        statusText = "è°ƒæ•´ä¸­...";
                    }
                } else {
                    // éæåˆçŠ¶æ€çš„æ‰‹åŠ¿åˆ¤æ–­

                    // ä¼˜å…ˆåˆ¤æ–­ ILY (å–œæ¬¢ä½ ) æ‰‹åŠ¿ï¼Œå› ä¸ºå®ƒçš„ç‰¹å¾å¾ˆæ˜æ˜¾ä¸”å®¹æ˜“è¢«è¯¯åˆ¤ä¸º OpenHand
                    // é€»è¾‘ï¼šæ‹‡æŒ‡+é£ŸæŒ‡+å°æŒ‡ä¼¸ç›´ï¼Œä¸”ä¸­æŒ‡+æ— åæŒ‡æ˜¯å¼¯æ›²çš„(å®½å®¹åº¦é«˜)
                    const isLoveSign = isThumbExtended && isIndexExt && isPinkyExt && isCurled(12, 10) && isCurled(16, 14);

                    // å‰ªåˆ€æ‰‹ï¼šé£ŸæŒ‡+ä¸­æŒ‡ä¼¸ç›´ï¼Œæ— åæŒ‡+å°æŒ‡å¼¯æ›²
                    const isVictory = isIndexExt && isMiddleExt && isCurled(16, 14) && isCurled(20, 18);

                    if (extendedCount === 0 && !isThumbExtended) {
                        // æ¡æ‹³ -> åœ£è¯æ ‘
                        detectedGesture = 'tree';
                        newRomanticMode = true;
                        statusText = "âœŠ ğŸ„ğŸ’° åœ£è¯æ ‘";
                    } else if (isLoveSign) {
                        // ILYæ‰‹åŠ¿ -> å–œæ¬¢ä½ 
                        detectedGesture = 'gesture1';
                        newRomanticMode = true;
                        statusText = "ğŸ¤Ÿ å–œæ¬¢ä½ ";
                    } else if (isVictory) {
                        // å‰ªåˆ€æ‰‹ -> æˆ‘
                        detectedGesture = 'gesture2';
                        newRomanticMode = false;
                        statusText = "âœŒï¸ æˆ‘";
                    } else if (extendedCount >= 4) {
                        // å¼ å¼€æ‰‹ -> æ•£å¼€
                        detectedGesture = 'idle';
                        newRomanticMode = false;
                        statusText = "ğŸ–ï¸ æ•£å¼€";
                    } else {
                        // å…¶ä»–è¿‡æ¸¡çŠ¶æ€ä¿æŒä¸å˜
                        detectedGesture = lastDetectedGesture;
                        statusText = "ğŸ–ï¸ " + (lastDetectedGesture === 'idle' ? "æ•£å¼€" : "ä¿æŒ...");
                    }
                }

                // æ‰‹åŠ¿é˜²æŠ–é€»è¾‘
                if (detectedGesture === lastDetectedGesture) {
                    gestureStableCounter++;
                } else {
                    gestureStableCounter = 0;
                    lastDetectedGesture = detectedGesture;
                }

                if (gestureStableCounter >= GESTURE_STABLE_THRESHOLD && detectedGesture !== currentModel) {
                    changeModel(detectedGesture);
                    gestureStableCounter = 0;
                }

                isRomanticMode = newRomanticMode;

                const depthPercent = Math.round(handDepth * 100);
                updateStatus(statusText + ` [${depthPercent}%]`, true);
            } else {
                updateStatus('ğŸ”’ ä¿æŒå½“å‰çŠ¶æ€', false);
            }
        }

        function updateStatus(text, isActive) {
            const el = document.getElementById('status-text');
            if (el) el.textContent = text;
            const indicator = document.querySelector('.status-indicator');
            if (indicator) {
                if (currentModel === 'tree') {
                    const goldShimmer = Math.floor((time * 10) % 2);
                    indicator.style.background = goldShimmer ? '#ffd700' : '#10b981';
                } else {
                    indicator.style.background = isActive ? '#ff1493' : '#666';
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            updateParticlePositions();
            updateFloatingImages();

            const isTextMode = (currentModel === 'gesture1' || currentModel === 'gesture2' || currentModel === 'gesture3');

            if (currentModel === 'tree') {
                particles.rotation.y += CONFIG.rotationSpeed * 1.2;
                particles.rotation.x = 0;
                particles.position.x = 0;
                particles.position.y = Math.sin(time * 0.8) * 0.04;
                particles.position.z = 0;
            } else if (isTextMode) {
                particles.rotation.y = 0;
                // æ–‡å­—ä¸å†è·Ÿéšæ‰‹åŠ¿ç§»åŠ¨ï¼Œå›ºå®šåœ¨å±å¹•ä¸­å¿ƒ
                particles.rotation.x = 0;
                particles.position.x += (0 - particles.position.x) * 0.1;
                particles.position.y += (0 - particles.position.y) * 0.1;
                particles.position.z = 0;
            } else if (currentModel === 'heart') {
                particles.rotation.y = Math.sin(time) * 0.1;
                particles.rotation.x = 0;
                particles.position.x = 0;
                particles.position.y = 0;
                particles.position.z = 0;
            } else {
                particles.rotation.y += CONFIG.rotationSpeed;
                particles.rotation.x = 0;
                particles.position.x = 0;
                particles.position.y = 0;
                particles.position.z = 0;
            }

            // æ›´æ–°å…‰æ ‡ä½ç½®
            if (cursorMesh) {
                cursorMesh.position.lerp(new THREE.Vector3(handPosition.x, handPosition.y, 0), 0.2);
                // ç®€å•çš„æåˆè§†è§‰åé¦ˆ
                const scale = (currentModel === 'heart' || currentModel === 'gesture3') ? 0.5 : 1.0;
                cursorMesh.scale.setScalar(scale);
            }
            renderer.render(scene, camera);
        }

        async function init() {
            try {
                initThreeJS();
                await initMediaPipe();

                const loading = document.getElementById('loading');
                if (loading) loading.style.display = 'none';

                animate();
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        init();
    </script>
</body>

</html>