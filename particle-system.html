<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3DÁ≤íÂ≠ê‰∫§‰∫íÁ≥ªÁªü - ARÊ®°Âºè</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }

        #video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            transform: scaleX(-1);
            filter: brightness(0.5);
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        #status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(15px);
            padding: 14px 28px;
            border-radius: 30px;
            font-size: 15px;
            z-index: 100;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            font-weight: 500;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ade80;
            margin-right: 10px;
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.6);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.6;
                transform: scale(1.1);
            }
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 24px;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }
    </style>
</head>

<body>
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Ê≠£Âú®ÂêØÂä®ARÊ®°Âºè...</div>
    </div>

    <video id="video" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <div id="status">
        <span class="status-indicator"></span>
        <span id="status-text">ÂàùÂßãÂåñ‰∏≠...</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>

    <script>
        const CONFIG = {
            particleCount: 15000,
            baseScale: 1.0,
            transitionSpeed: 0.15,
            rotationSpeed: 0.002,
            romanticColor: new THREE.Color('#ff1493'),
            normalColor: new THREE.Color('#667eea'),
            treeGreenColor: new THREE.Color('#10b981'),
            treeGoldColor: new THREE.Color('#fbbf24'),
            treeRedColor: new THREE.Color('#ef4444'),
            treeSilverColor: new THREE.Color('#e5e7eb'),
            treeBrownColor: new THREE.Color('#92400e'),
            coinGoldColor: new THREE.Color('#ffd700')
        };

        function createTextParticles(text, count) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 600;
            const height = 300;
            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            ctx.font = 'bold 120px "Microsoft YaHei", "Heiti SC", sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const validPixels = [];

            for (let y = 0; y < height; y += 3) {
                for (let x = 0; x < width; x += 3) {
                    const i = (y * width + x) * 4;
                    if (data[i] > 50) {
                        validPixels.push({
                            x: (x - width / 2) / 80,
                            y: -(y - height / 2) / 80
                        });
                    }
                }
            }

            const positions = [];
            for (let i = 0; i < count; i++) {
                if (validPixels.length > 0) {
                    const pixel = validPixels[Math.floor(Math.random() * validPixels.length)];
                    positions.push(
                        pixel.x + (Math.random() - 0.5) * 0.05,
                        pixel.y + (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.2
                    );
                } else {
                    const theta = Math.random() * Math.PI * 2;
                    const r = 2 * Math.random();
                    positions.push(r * Math.cos(theta), r * Math.sin(theta), (Math.random() - 0.5) * 0.5);
                }
            }
            return new Float32Array(positions);
        }

        const Models = {
            idle: (count) => {
                const positions = [];
                for (let i = 0; i < count; i++) {
                    positions.push(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 12,
                        (Math.random() - 0.5) * 10
                    );
                }
                return new Float32Array(positions);
            },
            heart: (count) => {
                const positions = [];
                for (let i = 0; i < count; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.pow(Math.random(), 0.5);
                    const depth = (Math.random() - 0.5);
                    const heartX = 16 * Math.pow(Math.sin(t), 3);
                    const heartY = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    const scale = 0.08;
                    const thicknessScale = 0.8;
                    positions.push(
                        heartX * r * scale,
                        heartY * r * scale,
                        depth * thicknessScale * (1 - r * 0.3)
                    );
                }
                return new Float32Array(positions);
            },
            tree: (count) => {
                const positions = [];
                const trunkCount = Math.floor(count * 0.04);
                for (let i = 0; i < trunkCount; i++) {
                    const h = Math.random() * 0.3;
                    const angle = Math.random() * Math.PI * 2;
                    const r = 0.12 + Math.random() * 0.08;
                    positions.push(r * Math.cos(angle), h - 2.0, r * Math.sin(angle));
                }
                const mainTreeCount = Math.floor(count * 0.45);
                for (let i = 0; i < mainTreeCount; i++) {
                    const h = Math.random();
                    const layer = Math.floor(h * 7);
                    const layerH = layer / 7;
                    const layerOffset = (h - layerH) * 7;
                    const angle = h * Math.PI * 18 + Math.random() * Math.PI / 4;
                    const baseR = (1 - layerH) * 2.3;
                    const waveR = Math.sin(layerOffset * Math.PI) * 0.35;
                    const r = (baseR + waveR) * (0.85 + Math.random() * 0.3);
                    const radialPos = Math.pow(Math.random(), 0.6);
                    positions.push(
                        r * radialPos * Math.cos(angle) * 0.6,
                        h * 4.2 - 1.7,
                        r * radialPos * Math.sin(angle) * 0.6
                    );
                }
                const ornamentCount = Math.floor(count * 0.12);
                const ornamentClusters = 25;
                for (let i = 0; i < ornamentCount; i++) {
                    const clusterIdx = Math.floor(Math.random() * ornamentClusters);
                    const clusterH = 0.15 + (clusterIdx / ornamentClusters) * 0.7;
                    const clusterAngle = (clusterIdx * 2.4) % (Math.PI * 2);
                    const clusterR = (1 - clusterH) * 2.0;
                    const cx = clusterR * Math.cos(clusterAngle) * 0.6;
                    const cy = clusterH * 4.2 - 1.7;
                    const cz = clusterR * Math.sin(clusterAngle) * 0.6;
                    const clusterSize = 0.12;
                    positions.push(
                        cx + (Math.random() - 0.5) * clusterSize,
                        cy + (Math.random() - 0.5) * clusterSize,
                        cz + (Math.random() - 0.5) * clusterSize
                    );
                }
                const lightCount = Math.floor(count * 0.08);
                for (let i = 0; i < lightCount; i++) {
                    const h = 0.1 + Math.random() * 0.85;
                    const angle = Math.random() * Math.PI * 2;
                    const r = (1 - h) * 2.3 * 1.08;
                    positions.push(r * Math.cos(angle) * 0.6, h * 4.2 - 1.7, r * Math.sin(angle) * 0.6);
                }
                const coinCount = Math.floor(count * 0.20);
                for (let i = 0; i < coinCount; i++) {
                    const spiralLayer = Math.floor(Math.random() * 3);
                    const spiralRadius = 2.8 + spiralLayer * 0.8;
                    const spiralH = Math.random();
                    const spiralAngle = Math.random() * Math.PI * 2;
                    const coinX = spiralRadius * Math.cos(spiralAngle) * 0.7;
                    const coinY = spiralH * 5.5 - 2.5;
                    const coinZ = spiralRadius * Math.sin(spiralAngle) * 0.7;
                    positions.push(
                        coinX + (Math.random() - 0.5) * 0.3,
                        coinY,
                        coinZ + (Math.random() - 0.5) * 0.3
                    );
                }
                const starCount = count - trunkCount - mainTreeCount - ornamentCount - lightCount - coinCount;
                for (let i = 0; i < starCount; i++) {
                    const progress = i / starCount;
                    const starAngle = progress * Math.PI * 2 * 3;
                    const inSpike = ((starAngle / (Math.PI * 2)) * 5) % 1;
                    let r = inSpike < 0.5 ? 0.35 + Math.random() * 0.25 : 0.12 + Math.random() * 0.12;
                    const theta = starAngle + (Math.random() - 0.5) * 0.3;
                    const verticalSpread = Math.random() * 0.15;
                    positions.push(
                        r * Math.cos(theta) * 0.7,
                        2.4 + verticalSpread,
                        r * Math.sin(theta) * 0.7
                    );
                }
                return new Float32Array(positions);
            },
            gesture3: (count) => createTextParticles("Â§ßÂ§¥ËèúËèú", count),
            gesture2: (count) => createTextParticles("Êàë", count),
            gesture1: (count) => createTextParticles("ÂñúÊ¨¢‰Ω†", count)
        };

        let scene, camera, renderer, particles;
        let cursorMesh;
        let currentModel = 'idle';
        let targetPositions, currentPositions;
        let currentScale = CONFIG.baseScale;
        let isRomanticMode = false;
        let time = 0;

        let handPosition = { x: 0, y: 0, z: 0 };
        let handVelocity = { x: 0, y: 0 };
        let prevHandPosition = { x: 0, y: 0 };

        let handDepth = 1.0;
        let targetDepth = 1.0;

        // ÈóÆÈ¢ò3Ëß£ÂÜ≥ÔºöÊâãÂäøÁ®≥ÂÆöÊÄßÊ£ÄÊµã
        let gestureStableCounter = 0;
        let lastDetectedGesture = 'idle';
        const GESTURE_STABLE_THRESHOLD = 8;

        let particleColors;

        const IMAGE_URLS = [
            'https://picsum.photos/id/237/200/300',
            'https://picsum.photos/id/10/200/300',
            'https://picsum.photos/id/1015/200/300',
            'https://picsum.photos/id/1016/200/300',
            'https://picsum.photos/id/1020/200/300',
            'https://picsum.photos/id/1025/200/300'
        ];

        let floatingImages = [];
        let imageGroup;

        function createFloatingImages() {
            imageGroup = new THREE.Group();
            scene.add(imageGroup);

            const loader = new THREE.TextureLoader();

            IMAGE_URLS.forEach((url, i) => {
                const texture = loader.load(url);
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.9
                });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(0.4, 0.6, 1);
                sprite.userData = {
                    id: i,
                    angleOffset: (i / IMAGE_URLS.length) * Math.PI * 2,
                    isSelected: false,
                    targetScale: 0.4
                };
                imageGroup.add(sprite);
                floatingImages.push(sprite);
            });
        }

        function updateFloatingImages() {
            if (!imageGroup) return;

            const t = time * 0.5;

            floatingImages.forEach((sprite, i) => {
                let targetPos = new THREE.Vector3();
                let targetScale = sprite.userData.isSelected ? 1.5 : 0.4;

                if (currentModel === 'tree') {
                    // Ëû∫ÊóãÊéíÂàóÈÄªËæë
                    const layerProgress = i / floatingImages.length;
                    const angle = sprite.userData.angleOffset + t * 0.5;
                    const radius = 2.0 - layerProgress * 1.0;
                    const y = -1.5 + layerProgress * 3.5;

                    targetPos.set(
                        Math.cos(angle) * radius,
                        y,
                        Math.sin(angle) * radius
                    );
                } else {
                    // Êï£ËêΩÈÄªËæë
                    const angle = sprite.userData.angleOffset + i;
                    const radius = 3.5;
                    targetPos.set(
                        Math.cos(angle) * radius,
                        Math.sin(t * 0.3 + i) * 2.5,
                        Math.sin(angle) * radius * 0.6
                    );
                }

                sprite.position.lerp(targetPos, 0.05);

                // Âπ≥ÊªëÁº©Êîæ
                const currentS = sprite.scale.x;
                const newS = currentS + (targetScale - currentS) * 0.1;
                sprite.scale.set(newS, newS * 1.5, 1);
            });
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = null;

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3.5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createParticleSystem();
            createFloatingImages();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            // ÂàõÂª∫ÂÖâÊ†á
            const cursorGeometry = new THREE.RingGeometry(0.08, 0.1, 32);
            const cursorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
            cursorMesh = new THREE.Mesh(cursorGeometry, cursorMaterial);
            scene.add(cursorMesh);

            window.addEventListener('resize', onWindowResize);
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            targetPositions = Models[currentModel](CONFIG.particleCount);
            currentPositions = new Float32Array(targetPositions);
            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

            particleColors = new Float32Array(CONFIG.particleCount * 3);
            for (let i = 0; i < CONFIG.particleCount; i++) {
                particleColors[i * 3] = CONFIG.normalColor.r;
                particleColors[i * 3 + 1] = CONFIG.normalColor.g;
                particleColors[i * 3 + 2] = CONFIG.normalColor.b;
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updateParticlePositions() {
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;
            const isTextMode = (currentModel === 'gesture1' || currentModel === 'gesture2' || currentModel === 'gesture3');

            for (let i = 0; i < positions.length; i += 3) {
                let targetX = targetPositions[i] * currentScale;
                let targetY = targetPositions[i + 1] * currentScale;
                let targetZ = targetPositions[i + 2] * currentScale;

                positions[i] += (targetX - positions[i]) * CONFIG.transitionSpeed;
                positions[i + 1] += (targetY - positions[i + 1]) * CONFIG.transitionSpeed;
                positions[i + 2] += (targetZ - positions[i + 2]) * CONFIG.transitionSpeed;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            if (currentModel === 'tree') {
                const particleCount = CONFIG.particleCount;
                const trunkEnd = Math.floor(particleCount * 0.04);
                const mainTreeEnd = trunkEnd + Math.floor(particleCount * 0.45);
                const ornamentEnd = mainTreeEnd + Math.floor(particleCount * 0.12);
                const lightEnd = ornamentEnd + Math.floor(particleCount * 0.08);
                const coinEnd = lightEnd + Math.floor(particleCount * 0.20);

                for (let i = 0; i < particleCount; i++) {
                    let targetColor;
                    if (i < trunkEnd) {
                        targetColor = CONFIG.treeBrownColor;
                    } else if (i < mainTreeEnd) {
                        targetColor = CONFIG.treeGreenColor;
                    } else if (i < ornamentEnd) {
                        targetColor = (i % 2 === 0) ? CONFIG.treeRedColor : CONFIG.treeSilverColor;
                    } else if (i < lightEnd) {
                        const colorIndex = Math.floor((i + time * 10) % 5);
                        if (colorIndex === 0) targetColor = CONFIG.treeRedColor;
                        else if (colorIndex === 1) targetColor = CONFIG.treeGreenColor;
                        else if (colorIndex === 2) targetColor = new THREE.Color('#3b82f6');
                        else if (colorIndex === 3) targetColor = CONFIG.treeGoldColor;
                        else targetColor = CONFIG.treeSilverColor;
                    } else if (i < coinEnd) {
                        const shimmer = (Math.sin(time * 8 + i * 0.1) + 1) / 2;
                        const goldBase = CONFIG.coinGoldColor.clone();
                        const goldBright = new THREE.Color('#ffed4e');
                        targetColor = goldBase.clone().lerp(goldBright, shimmer * 0.6);
                    } else {
                        const sparkle = (Math.sin(time * 15 + i * 0.05) + 1) / 2;
                        targetColor = CONFIG.treeGoldColor.clone().lerp(new THREE.Color('#fff9e6'), sparkle * 0.8);
                    }
                    colors[i * 3] += (targetColor.r - colors[i * 3]) * 0.1;
                    colors[i * 3 + 1] += (targetColor.g - colors[i * 3 + 1]) * 0.1;
                    colors[i * 3 + 2] += (targetColor.b - colors[i * 3 + 2]) * 0.1;
                }
                particles.geometry.attributes.color.needsUpdate = true;
            } else {
                let targetColor = CONFIG.normalColor;
                if (currentModel === 'heart' || currentModel === 'gesture1') {
                    targetColor = CONFIG.romanticColor;
                }
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    colors[i * 3] += (targetColor.r - colors[i * 3]) * 0.05;
                    colors[i * 3 + 1] += (targetColor.g - colors[i * 3 + 1]) * 0.05;
                    colors[i * 3 + 2] += (targetColor.b - colors[i * 3 + 2]) * 0.05;
                }
                particles.geometry.attributes.color.needsUpdate = true;
            }

            // ÈóÆÈ¢ò2Ëß£ÂÜ≥ÔºöÊâÄÊúâÊ®°ÂûãÈÉΩÂ∫îÁî®Ê∑±Â∫¶Áº©Êîæ
            if (isRomanticMode) {
                if (currentModel === 'tree') {
                    const pulse = 1 + Math.sin(time * 2.5) * 0.06;
                    particles.scale.setScalar(pulse * handDepth);
                    particles.material.opacity = 0.92 + Math.sin(time * 6) * 0.08;
                } else if (isTextMode) {
                    // ÊñáÂ≠ó‰∏çÂÜçË∑üÈöèÊâãÂäøÁßªÂä®ÔºåÂõ∫ÂÆöÂú®Â±èÂπï‰∏≠ÂøÉ\n                particles.rotation.y = 0;\n                particles.rotation.x = 0;\n                particles.position.x += (0 - particles.position.x) * 0.1;\n                particles.position.y += (0 - particles.position.y) * 0.1;\n                particles.position.z = 0;\n                    particles.scale.setScalar(pulse * handDepth);
                    particles.material.opacity = 0.85 + Math.sin(time * 10) * 0.15;
                }
            } else {
                particles.scale.setScalar(handDepth);
                particles.material.opacity = 0.95;
            }

            particles.material.size = 0.05 * handDepth;
        }

        function changeModel(modelName) {
            if (currentModel !== modelName && Models[modelName]) {
                currentModel = modelName;
                targetPositions = Models[modelName](CONFIG.particleCount);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let hands;

        async function initMediaPipe() {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandsResults);

            const videoElement = document.getElementById('video');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720, facingMode: 'user' }
                });
                videoElement.srcObject = stream;
                await new Promise(resolve => videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    resolve();
                });

                async function sendFrame() {
                    await hands.send({ image: videoElement });
                    requestAnimationFrame(sendFrame);
                }
                sendFrame();
                updateStatus('üé• ARÊ®°ÂºèÂ∞±Áª™ - ËØ∑Â±ïÁ§∫ÊâãÂäø', true);
            } catch (error) {
                console.error('ÊëÑÂÉèÂ§¥ÈîôËØØ:', error);
                updateStatus('ÊëÑÂÉèÂ§¥ËÆøÈóÆÂ§±Ë¥•', false);
            }
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                const palm = landmarks[9];
                const newX = -(palm.x - 0.5) * 4;
                const newY = -(palm.y - 0.5) * 3;

                const thumbTip = landmarks[4];
                const pinkyTip = landmarks[20];
                const handWidth = Math.sqrt(
                    Math.pow(thumbTip.x - pinkyTip.x, 2) +
                    Math.pow(thumbTip.y - pinkyTip.y, 2)
                );

                // ÈóÆÈ¢ò3Ëß£ÂÜ≥ÔºöÊâãÂøÖÈ°ªË∂≥Â§üÂ§ßÊâçËØÜÂà´ÔºåÈÅøÂÖçËØØÂà§
                const isHandSizeSufficient = handWidth > 0.12;
                if (!isHandSizeSufficient) {
                    updateStatus('üîí ‰øùÊåÅÂΩìÂâçÁä∂ÊÄÅ (ÊâãÂ§™Â∞è/Â§™Ëøú)', false);
                    return;
                }

                targetDepth = Math.max(0.5, Math.min(2.0, handWidth * 4));
                handDepth += (targetDepth - handDepth) * 0.1;

                handVelocity.x = newX - prevHandPosition.x;
                handVelocity.y = newY - prevHandPosition.y;
                prevHandPosition.x = newX;
                prevHandPosition.y = newY;
                handPosition.x = newX;
                handPosition.y = newY;

                const indexTip = landmarks[8];
                const thumbIp = landmarks[3];

                // --- ÂõæÁâá‰∫§‰∫íÈÄªËæë ---
                // ‰ΩøÁî®ÊâãÊéå‰∏≠ÂøÉ‰Ωú‰∏∫ÂÖâÊ†á‰ΩçÁΩÆÔºåÊõ¥Á®≥ÂÆö
                const cursorX = handPosition.x;
                const cursorY = handPosition.y;

                let interactingImage = null;
                if (floatingImages) {
                    let minDist = 100;
                    floatingImages.forEach(sprite => {
                        sprite.userData.isSelected = false; // Reset
                        const dist = Math.sqrt(
                            Math.pow(sprite.position.x - cursorX, 2) +
                            Math.pow(sprite.position.y - cursorY, 2)
                        );
                        if (dist < 0.5 && dist < minDist) {
                            minDist = dist;
                            interactingImage = sprite;
                        }
                    });
                }

                // ÈóÆÈ¢ò1Ëß£ÂÜ≥ÔºöÊîπËøõÊâãÂäøËØÜÂà´
                const thumbIndexDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                const thumbCurled = thumbTip.y > thumbIp.y - 0.02;
                const isPinch = thumbIndexDist < 0.08 && indexTip.y < landmarks[6].y;

                // Ê£ÄÊü•ÊòØÂê¶Âú®‰∫§‰∫íÂõæÁâá
                let isImageInteraction = false;
                if (interactingImage && isPinch) {
                    interactingImage.userData.isSelected = true;
                    isImageInteraction = true;
                }

                const otherTips = [12, 16, 20];
                const otherPips = [10, 14, 18];
                let otherFingersUpCount = 0;
                for (let i = 0; i < 3; i++) {
                    if (landmarks[otherTips[i]].y < landmarks[otherPips[i]].y - 0.02) {
                        otherFingersUpCount++;
                    }
                }

                const allTips = [8, 12, 16, 20];
                const allPips = [6, 10, 14, 18];
                let totalExtended = 0;
                for (let i = 0; i < allTips.length; i++) {
                    if (landmarks[allTips[i]].y < landmarks[allPips[i]].y - 0.02) {
                        totalExtended++;
                    }
                }

                const thumbMcp = landmarks[2];
                const thumbDistance = Math.abs(thumbTip.x - thumbMcp.x);
                const thumbExtended = thumbDistance > 0.08;

                let detectedGesture = 'idle';
                let statusText = "";
                let newRomanticMode = isRomanticMode;

                // ÊâãÊåáÁä∂ÊÄÅÊ£ÄÊµã
                const isIndexUp = landmarks[8].y < landmarks[6].y - 0.02;
                const isMiddleUp = landmarks[12].y < landmarks[10].y - 0.02;
                const isRingUp = landmarks[16].y < landmarks[14].y - 0.02;
                const isPinkyUp = landmarks[20].y < landmarks[18].y - 0.02;

                const isLoveSign = thumbExtended && isIndexUp && !isMiddleUp && !isRingUp && isPinkyUp;
                const isVictory = !thumbExtended && isIndexUp && isMiddleUp && !isRingUp && !isPinkyUp;

                if (isImageInteraction) {
                    detectedGesture = currentModel;
                    statusText = "üñºÔ∏è Êü•ÁúãÁÖßÁâá";
                    newRomanticMode = isRomanticMode;
                } else if (isPinch) {
                    if (otherFingersUpCount === 0) {
                        detectedGesture = 'heart';
                        newRomanticMode = true;
                        statusText = "‚ù§Ô∏è Áà±ÂøÉ";
                    } else if (otherFingersUpCount >= 2) {
                        detectedGesture = 'gesture3';
                        newRomanticMode = false;
                        statusText = "üëå Â§ßÂ§¥ËèúËèú";
                    } else {
                        detectedGesture = lastDetectedGesture;
                        statusText = "Ë∞ÉÊï¥‰∏≠...";
                    }
                } else {
                    if (totalExtended === 0 && thumbCurled) {
                        detectedGesture = 'tree';
                        newRomanticMode = true;
                        statusText = "‚úä üéÑüí∞ Âú£ËØûÊ†ë";
                    } else if (isLoveSign) {
                        detectedGesture = 'gesture1';
                        newRomanticMode = true;
                        statusText = "ü§ü ÂñúÊ¨¢‰Ω†";
                    } else if (isVictory || (totalExtended === 2 && !thumbExtended)) {
                        detectedGesture = 'gesture2';
                        newRomanticMode = false;
                        statusText = "‚úåÔ∏è Êàë";
                    } else if (totalExtended === 5 || (totalExtended === 4 && thumbExtended)) {
                        detectedGesture = 'idle';
                        newRomanticMode = false;
                        statusText = "üñêÔ∏è Êï£ÂºÄ";
                    } else {
                        // ÂçïÊåáÊåáÂêëÁ≠âËøáÊ∏°Âä®‰Ωú‰øùÊåÅ‰∏ä‰∏ÄÁä∂ÊÄÅÔºåÈÅøÂÖçËØØËß¶
                        detectedGesture = lastDetectedGesture;
                        statusText = "üñêÔ∏è " + (lastDetectedGesture === 'idle' ? "Êï£ÂºÄ" : "‰øùÊåÅ...");
                    }
                }

                // ÈóÆÈ¢ò3Ëß£ÂÜ≥ÔºöÊâãÂäøÁ®≥ÂÆöÊÄßÊ£ÄÊµã
                if (detectedGesture === lastDetectedGesture) {
                    gestureStableCounter++;
                } else {
                    gestureStableCounter = 0;
                    lastDetectedGesture = detectedGesture;
                }

                if (gestureStableCounter >= GESTURE_STABLE_THRESHOLD && detectedGesture !== currentModel) {
                    changeModel(detectedGesture);
                    gestureStableCounter = 0;
                }

                isRomanticMode = newRomanticMode;

                const depthPercent = Math.round(handDepth * 100);
                updateStatus(statusText + ` [${depthPercent}%]`, true);
            } else {
                updateStatus('üîí ‰øùÊåÅÂΩìÂâçÁä∂ÊÄÅ', false);
            }
        }

        function updateStatus(text, isActive) {
            const el = document.getElementById('status-text');
            if (el) el.textContent = text;
            const indicator = document.querySelector('.status-indicator');
            if (indicator) {
                if (currentModel === 'tree') {
                    const goldShimmer = Math.floor((time * 10) % 2);
                    indicator.style.background = goldShimmer ? '#ffd700' : '#10b981';
                } else {
                    indicator.style.background = isActive ? '#ff1493' : '#666';
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            updateParticlePositions();
            updateFloatingImages();

            const isTextMode = (currentModel === 'gesture1' || currentModel === 'gesture2' || currentModel === 'gesture3');

            if (currentModel === 'tree') {
                particles.rotation.y += CONFIG.rotationSpeed * 1.2;
                particles.rotation.x = 0;
                particles.position.x = 0;
                particles.position.y = Math.sin(time * 0.8) * 0.04;
                particles.position.z = 0;
            } else if (isTextMode) {
                particles.rotation.y = 0;
                // ÊñáÂ≠ó‰∏çÂÜçË∑üÈöèÊâãÂäøÁßªÂä®ÔºåÂõ∫ÂÆöÂú®Â±èÂπï‰∏≠ÂøÉ
                particles.rotation.x = 0;
                particles.position.x += (0 - particles.position.x) * 0.1;
                particles.position.y += (0 - particles.position.y) * 0.1;
                particles.position.z = 0;
            } else if (currentModel === 'heart') {
                particles.rotation.y = Math.sin(time) * 0.1;
                particles.rotation.x = 0;
                particles.position.x = 0;
                particles.position.y = 0;
                particles.position.z = 0;
            } else {
                particles.rotation.y += CONFIG.rotationSpeed;
                particles.rotation.x = 0;
                particles.position.x = 0;
                particles.position.y = 0;
                particles.position.z = 0;
            }

            // Êõ¥Êñ∞ÂÖâÊ†á‰ΩçÁΩÆ
            if (cursorMesh) {
                cursorMesh.position.lerp(new THREE.Vector3(handPosition.x, handPosition.y, 0), 0.2);
                // ÁÆÄÂçïÁöÑÊçèÂêàËßÜËßâÂèçÈ¶à
                const scale = (currentModel === 'heart' || currentModel === 'gesture3') ? 0.5 : 1.0;
                cursorMesh.scale.setScalar(scale);
            }
            renderer.render(scene, camera);
        }

        async function init() {
            try {
                initThreeJS();
                await initMediaPipe();

                const loading = document.getElementById('loading');
                if (loading) loading.style.display = 'none';

                animate();
            } catch (error) {
                console.error('ÂàùÂßãÂåñÂ§±Ë¥•:', error);
            }
        }

        init();
    </script>
</body>

</html>